Creator:        TeX
Producer:       Appligent StampPDF Batch, version 5.1
CreationDate:   Sun Apr 22 15:10:41 2012
ModDate:        Tue Jun 19 12:54:10 2012
Tagged:         no
Pages:          5
Encrypted:      no
Page size:      612 x 792 pts (letter)
File size:      294947 bytes
Optimized:      no
PDF version:    1.7
ISIT'2012 1569560833

List Decoding Algorithms based on Gröbner Bases
for General One-Point AG Codes
Olav Geil∗ , Ryutaroh Matsumoto† and Diego Ruano∗

∗ Department

† Department

of Mathematical Sciences, Aalborg University, Denmark
of Communications and Integrated Systems, Tokyo Institute of Technology, 152-8550 Japan
system [11], and we veriﬁed that the proposed algorithm can
correct more errors than [4], [12], [15], [16] with manageable computational complexity. The omitted proofs and the
implementation of the proposed algorithm are available as the
expanded versions [7], [8] of this conference paper.

Abstract—We generalize the list decoding algorithm for Hermitian codes proposed by Lee and O’Sullivan [15] based on Gröbner
bases to general one-point AG codes, under an assumption
weaker than one used by Beelen and Brander [4]. By using
the same principle, we also generalize the unique decoding
algorithm for one-point AG codes over the Miura-Kamiya Cab
curves proposed by Lee, Bras-Amorós and O’Sullivan [14] to
general one-point AG codes, without any assumption. Finally we
extend the latter unique decoding algorithm to list decoding,
modify it so that it can be used with the Feng-Rao improved
code construction, prove equality between its error correcting
capability and half the minimum distance lower bound by
Andersen and Geil [3] that has not been done in the original
proposal, and remove the unnecessary computational steps so
that it can run faster.

II. Notation and Preliminary
Our study heavily relies on the standard form of algebraic
curves introduced independently by Pellikaan [10] and Miura
[20]. Let F/Fq be an algebraic function ﬁeld of one variable
over a ﬁnite ﬁeld Fq with q elements. Let g be the genus of F.
Fix n + 1 distinct places Q, P1 , . . . , Pn of degree one in F and
a nonnegative integer u. We consider the following one-point
algebraic geometry (AG) code
Cu = {( f (P1 ), . . . , f (Pn )) | f ∈ L(uQ)}.
Suppose that the Weierstrass semigroup H(Q) at Q is generated by a1 , . . . , at , and choose t elements x1 , . . . , xt in F
whose pole divisors are (xi )∞ = ai Q for i = 1, . . . , t. Without
loss of generality we may assume the availability of such x1 ,
. . . , xt , because otherwise we cannot ﬁnd a basis of Cu for
every u. Then we have that L(∞Q) = ∪∞ L(iQ) is equal to
i=1
Fq [x1 , . . . , xt ] [21]. Let mi be the maximal ideal Pi ∩ L(∞Q)
of L(∞Q) associated with the place Pi . We express L(∞Q)
as a residue class ring Fq [X1 , . . . , Xt ]/I of the polynomial
ring Fq [X1 , . . . , Xt ], where X1 , . . . , Xt are transcendental
over Fq , and I is the kernel of the canonical homomorphism
sending Xi to xi . Pellikaan and Miura [10], [20] identiﬁed the
following convenient representation of L(∞Q) by using the
Gröbner basis theory [1]. The following review is borrowed
from [18]. Hereafter, we assume that the reader is familiar
with the Gröbner basis theory in [1].
Let N0 be the set of nonnegative integers. For (m1 , . . . , mt ),
(n1 , . . . , nt ) ∈ Nt0 , we deﬁne the monomial order such that
(m1 , . . . , mt ) (n1 , . . . , nt ) if a1 m1 +· · ·+at mt > a1 n1 +· · ·+at nt ,
or a1 m1 + · · · + at mt = a1 n1 + · · · + at nt , and m1 = n1 , m2 = n2 ,
. . . , mi−1 = ni−1 , mi < ni , for some 1 ≤ i ≤ t. Note that a
Gröbner basis of I with respect to can be computed by [21,
Theorem 15] or [22, Theorem 4.1], starting from any aﬃne
deﬁning equations of F/Fq .
For i = 0, . . . , a1 − 1, we deﬁne bi = min{m ∈ H(Q) | m ≡ i
(mod a1 )}, and Li to be the minimum element (m1 , . . . , mt ) ∈
Nt0 with respect to such that a1 m1 + · · · + at mt = bi . Then we
have 1 = 0 if we write Li as ( 1 , . . . , t ). For each Li = (0,
i2
it
i2 , . . . , it ), deﬁne yi = x2 · · · xt ∈ L(∞Q).
The footprint of I, denoted by ∆(I), is {(m1 , . . . , mt ) ∈
m
Nt0 | X1 1 · · · Xtmt is not the leading monomial of any nonzero
m
polynomial in I with respect to }, and deﬁne B = {x1 1 · · · xtmt |
(m1 , . . . , mt ) ∈ ∆(I)}. Then B is a basis of L(∞Q) as an Fq linear space [1], two distinct elements in B have diﬀerent pole

I. Introduction
We consider the list decoding of one-point algebraic geometry (AG) codes. Guruswami and Sudan [12] proposed the wellknown list decoding algorithm for one-point AG codes, which
consists of the interpolation step and the factorization step.
The interpolation step has large computational complexity
and many researchers have proposed faster interpolation steps,
see [4, Figure 1]. Lee and O’Sullivan [15] proposed a faster
interpolation step based on the Gröbner basis theory for onepoint Hermitian codes. Little [16] generalized their method
[15] by using the same assumption as Beelen and Brander [4,
Assumptions 1 and 2]. The aim of the ﬁrst part of this paper
is to generalize the method [15] to an even wider class of
algebraic curves than [16].
The second part proposes another list decoding algorithm
whose error-correcting capability is higher than [4], [12],
[15], [16] and whose computational complexity is empirically
manageable. Lee, Bras-Amorós and O’Sullivan [13], [14]
proposed a unique decoding (not list decoding) algorithm for
primal codes based on the majority voting inside Gröbner
bases.
There were several rooms for improvements in the original
result [14], namely, (a) they have not clariﬁed the relation
between its error-correcting capability and existing minimum
distance lower bounds except for the Hermitian codes, (b)
they assumed that the maximum pole order used for code
construction is less than the code length, and (c) they have
not shown how to use the method with the Feng-Rao improved
code construction [6]. In the second part of this paper, we shall
(1) prove that the error-correcting capability of the original
proposal is always equal to half of the bound in [3] for the
minimum distance of one-point primal codes, (2) generalize
their algorithm to work with any one-point AG codes, (3)
modify their algorithm to a list decoding algorithm, (4) remove
the assumptions (b) and (c) above, and (5) remove unnecessary
computational steps from the original proposal. The proposed
algorithm is implemented on the Singular computer algebra

1

orders at Q, and
B
m
= {x1 x22 · · · , xt t | m ∈ N0 , (0, 2 , . . . , t ) ∈ {L0 , . . . , La1 −1 }}
m
= {x1 yi | m ∈ N0 , i = 0, . . . , a1 − 1}.
(1)
Equation (1) shows that L(∞Q) is a free Fq [x1 ]-module with
a basis {y0 , . . . , ya1 −1 }.
Let vQ be the unique valuation in F associated with the
place Q. The semigroup S = H(Q) is equal to S = {ia1 −
vQ (y j ) | 0 ≤ i, 0 ≤ j < a1 }. For each nongap s ∈ S there is
i
a unique monomial x1 y j ∈ L(∞Q) with 0 ≤ j < a1 such that
i
−vQ (x1 y j ) = s by [18, Proposition 3.18], and let us denote
this monomial by ϕ s . Let Γ ⊂ S , and we may consider the
one-point codes
CΓ = (ϕ s (P1 ), . . . , ϕ s (Pn )) | s ∈ Γ .
(2)
One motivation for considering these codes is that it was
shown in [3] how to increase the dimension of the one-point
codes without decreasing the bound for the minimum distance.
III. Generalization of Lee-O’Sullivan’s List Decoding to
General One-Point AG Codes
A. Background on Lee-O’Sullivan’s Algorithm
In the famous list decoding algorithm for the one-point AG
codes in [12], we have to compute the univariate interpolation
polynomial whose coeﬃcients belong to L(∞Q). Lee and
O’Sullivan [15] proposed a faster algorithm to compute the
interpolation polynomial for the Hermitian one-point codes.
Their algorithm was sped up and generalized to one-point
AG codes over the so-called Cab curves [19] by Beelen and
Brander [4] with an additional assumption. In this section
we generalize Lee-O’Sullivan’s procedure to general one-point
AG codes with an assumption weaker than [4, Assumption 2],
which will be introduced in and used after Assumption 2.
Let m be the multiplicity parameter in [12]. Lee and
O’Sullivan introduced the ideal Ir,m containing the interpolation polynomial corresponding to the received word r and
the multiplicity m. The ideal Ir,m contains the interpolation
polynomial as its minimal nonzero element with respect to the
monomial order. We will give another module Ir,m for general
algebraic curves, from which we can also obtain the required
interpolation polynomial.
B. Deﬁnition of the Interpolation Ideal
Let r = (r1 , . . . , rn ) ∈ Fn be the received word. For a divisor
q
G of F, we deﬁne L(−G + ∞Q) = ∞ L(−G + iQ). We see
i=1
that L(−G + ∞Q) is an ideal of L(∞Q) [17].
Let hr ∈ L(∞Q) such that hr (Pi ) = ri . Computation of such
hr is easy provided that we can construct generator matrices for
Cu for every u. We can choose hr so that −vQ (hr ) ≤ n + 2g − 1.
Let Z be transcendental over L(∞Q), and D = P1 + · · · + Pn .
Deﬁne the set Ir,m = {Q(Z) ∈ L(∞Q)[Z] | Q(Z) has multiplicity m for all (Pi , ri )}. This deﬁnition of the multiplicity
is the same as [12]. Therefore, we can ﬁnd the interpolation
polynomial used in [12] from Ir,m . We shall explain how to
ﬁnd eﬃciently the interpolation polynomial from Ir,m .
For i = 0, . . . , m and j = 0, . . . , a1 − 1, let ηi, j to be an
element in L(−iD + ∞Q) such that −vQ (ηi, j ) is the minimum
among {−vQ (η) ∈ L(−iD+∞Q) | −vQ (η) ≡ j (mod a1 )}. Such
elements ηi, j can be computed by [17] before receiving r. It
was also shown [17] that {ηi, j | j = 0, . . . , a1 − 1} generates
L(−iD + ∞Q) as an Fq [x1 ]-module. Note also that we can
choose η0,i = yi deﬁned in Sec. II. By Eq. (1), all ηi, j and hr
can be expressed as polynomials in x1 and y0 , . . . , ya1 −1 . Thus

we have
Theorem 1: Let ≥ m. {(Z − hr )m−i ηi, j | i = 0, . . . , m, j = 0,
. . . , a1 − 1} ∪{Z −m (Z − hr )m η0, j | = 1, . . . , j = 0, . . . , a1 − 1}
generates Ir,m, = Ir,m ∩ {Q(Z) ∈ L(∞Q)[Z] | degZ Q(Z) ≤ } as
an Fq [x1 ]-module.
C. Computation of the Interpolated Polynomial from the Interpolation Ideal Ir,m
t+1
For (m1 , . . . , mt , mt+1 ), (n1 , . . . , nt , nt+1 ) ∈ N0 , we deﬁne
the monomial order u in Fq [X1 , . . . , Xt , Z] such that (m1 , . . . ,
mt , mt+1 ) (n1 , . . . , nt , nt+1 ) if a1 m1 +· · ·+at mt +umt+1 > a1 n1 +
· · ·+at nt +unt+1 , or a1 m1 +· · ·+at mt +umt+1 = a1 n1 +· · ·+at nt +
unt+1 , and m1 = n1 , m2 = n2 , . . . , mi−1 = ni−1 , mi < ni , for some
1 ≤ i ≤ t + 1. As done in [15], the interpolation polynomial
is the smallest nonzero polynomial with respect to u in the
preimage of Ir,m . Such a smallest element can be found from
a Gröbner basis of the Fq [x1 ]-module Ir,m, in Theorem 1. To
ﬁnd such a Gröbner basis, Lee and O’Sullivan proposed the
following general purpose algorithm as [15, Algorithm G].
Their algorithm [15, Algorithm G] eﬃciently ﬁnds a Gröbner basis of submodules of Fq [x1 ] s for a special kind of
generating set and monomial orders. Please refer to [1] for
Gröbner bases for modules. Let e1 , . . . , e s be the standard
basis of Fq [x1 ] s . Let u x , u1 , . . . , u s be positive integers. Deﬁne
n
n
the monomial order in Fq [x1 ] s such that x11 ei LO x12 e j if
n1 u x + ui > n2 u x + u j or n1 u x + ui = n2 u x + u j and i > j. For
s
f = i=1 fi (x1 )ei ∈ Fq [x1 ] s , deﬁne ind( f ) = max{i | fi (x1 ) 0},
where fi (x1 ) denotes a univariate polynomial in x1 over Fq .
Their algorithm [15, Algorithm G] eﬃciently computes a
Gröbner basis of a module generated by g1 , . . . , g s ∈ Fq [x1 ] s
such that ind(gi ) = i. The computational complexity is also
evaluated in [15, Proposition 16].
Let be the maximum Z-degree of the interpolation polynomial in [12]. The set Ir,m, in Theorem 1 is an Fq [x1 ]submodule of Fq [x1 ]a1 ( +1) with the module basis {y j Z k | j = 0,
. . . , a1 − 1, k = 0, . . . , }.
Assumption 2: We assume that we have f ∈ L(∞Q) whose
zero divisor ( f )0 = D.
Observe that Assumption 2 is implied by [4, Assumption 2]
and is weaker than [4, Assumption 2]. Let f be the ideal
of L(∞Q) generated by f . By [17, Corollary 2.3] we have
L(−D + ∞Q) = f . By [17, Corollary 2.5] we have L(−iD +
∞Q) = f i .
Without loss of generality we may assume existence of x ∈
L(∞Q) such that f ∈ Fq [x ]. By changing the choice of x1 , . . . ,
xt if necessary, we may assume x1 = x and f ∈ Fq [x1 ] without
loss of generality, while it is better to make −vQ (x1 ) as small
as possible in order to reduce the computational complexity.
Under the assumption f ∈ Fq [x1 ], f i y j satisﬁes the required
condition for ηi, j in Theorem 1. By naming y j zk as e1+ j+ku ,
the generators in Theorem 1 satisfy the assumption in [15,
Algorithm G] and we can eﬃciently compute the interpolation
polynomial required in the list decoding algorithm in [12].
Proposition 3: We assign the weight −ivQ (x1 ) − vQ (y j ) + ku
i
to the module element x1 y j zk when we use [15, Algorithm G]
to ﬁnd the minimal Gröbner basis of Ir,m, . Under Assumption
2, the number of multiplications in [15, Algorithm G] with
the generators in Theorem 1 is at most
a1 ( +1)

[max{−vQ (y j )} + m(n + 2g − 1) + u( − m)]2 a−1
1
j

2

i2 . (3)
i=1

IV. New List Decoding based on Majority Voting inside
Gr¨ bner Bases
o
A unique decoding algorithm for one-point codes over Cab
curves has recently been introduced in [14]. This algorithm is
also based on the interpolation approach, an ideal containing
the interpolation polynomials of a received word is computed.
Moreover, the algorithm in [14] combines the interpolation approach with syndrome decoding with majority voting scheme.
However, this algorithm only considers the non-improved code
Cu assuming that u < n.
The aim of this section is to extend this algorithm for
one-point codes deﬁned over general curves without assuming
u < n, besides, the modiﬁed algorithm performs list decoding.
Furthermore, we can speed up the algorithm and deal with
Feng-Rao improved codes by changing the majority voting.
Still, the main structure of the algorithm remains the same.
We stress that we do not assume Assumption 2 in this section.
Let F/Fq be an algebraic function ﬁeld as in Sec. II, we
consider the same notation and concepts already introduced
in Secs. II and III. Let Γ = {s1 , s2 , . . . , sk } ⊂ S and consider
the code CΓ deﬁned in Eq. (2). We will assume that Γ = Γindep ,
where
Γindep = {s ∈ Γ | ev(ϕ s ) ev(ϕ s ) : s ∈ Γ, s < s }, (4)
since there is no interest in considering s ∈ Γ \ Γindep . Let r be
a received word. Choose any codeword in CΓ as c and deﬁne
e(c) = r − c. Then there is a unique
µ=
ωs ϕs ,
(5)

the same proofs in [14] will hold after considering y j instead
of y j and prec(s) instead of s − 1, where prec(s) = max{s ∈
S : s < s}, for s ∈ S . The reader should also be aware that
in this section we follow the notation of previous sections,
however, the notation in [14] is diﬀerent. Namely, P∞ denotes
Q, R denotes L(∞Q), δ denotes −vQ , x denotes x1 and the
semigroup S is the one generated by {a, a1 , . . . , at } in [14].
A. Decoding Algorithm
We can now describe the extension of the algorithm in [14].
For a constant τ ∈ N the following procedure ﬁnds all the
codewords within Hamming distance τ from the received word
r
1) Initialization: Let N = −vQ (hr ) and G be the Gröbner
basis of the Fq [x1 ]-module Ir deﬁned above. Let r(sk ) = r
and B(sk ) = G. We consider now the steps Pairing,
Voting, Rebasing for s ∈ S ∩ [0, N] in decreasing order
until the earlier termination condition is veriﬁed or,
otherwise, until s = s1 .
2) Pairing: We consider that
r(s) = e +ev(µ(s) ), µ(s) = ω s ϕ s +µ(prec(s)) , µ(prec(s)) ∈ Lprec(s)
(7)
and we will determine ω s by majority voting in step 3)
provided that wt(e ) ≤ τ. Let B(s) = {g(s) , fi(s) | 0 ≤ i <
i
a1 } be a Gröbner basis of the Fq [x1 ]-module Ir(s) with
respect to > s where
g(s) =
ci, j y j z +
di, j y j , with ci, j , di, j ∈ Fq [x1 ],
i
0≤ j<a1

s∈Γ

with c = ev(µ) = (µ(P1 ), . . . , µ(Pn )).
As in Sec. III-C, we consider L(∞Q) as an F[x1 ]-module
of rank a1 with basis {y j | 0 ≤ j < a1 }. For f ∈ F[x1 ], we
k
k
denote by f [x1 ] the coeﬃcient of the term x1 in f .
The following ideal containing the interpolation polynomial
for a received word r is deﬁned in [14],
Ir = { f (z) ∈ L(∞Q)z ⊕ L(∞Q) | vPi ( f (ri )) ≥ 1, 1 ≤ i ≤ n}.
Moreover, Ir is a special case of the interpolation ideal in
[15]. Thus, by Sec. III, we have that L(∞Q)z ⊕ L(∞Q) is a
free Fq [x1 ]-module of rank 2a1 with basis {y j z, y j | 0 ≤ j <
a1 }. Hence an element in L(∞Q)z ⊕ L(∞Q) can be uniquely
expressed by monomials in
i
Ω1 = {x1 y j zk | 0 ≤ i, 0 ≤ j < a1 , 0 ≤ k ≤ 1}.
Recall also that an element in L(∞Q) can be uniquely exi
pressed by monomials in Ω0 = {x1 y j | 0 ≤ i, 0 ≤ j < a1 }.
By the previous section,
G = {η0 , η1 , . . . , ηa1 −1 , z − hr , y1 (z − hr ), . . . , ya1 −1 (z − hr )},
with ηi and hr as in Sec. III, is a Gröbner basis of the Fq [x1 ]module Ir with respect to the monomial order >−vQ (hr ) deﬁned
in Sec. III-C.
Let Je(c) = ∩ei 0 mi be the ideal of the error vector and let
i ∈ L(∞Q) such that −vQ ( i ) is the minimum among { f ∈
Je(c) | −vQ ( f ) ≡ i (mod a1 )}, for i = 0, . . . , a1 − 1. One has
that { 0 , 1 , . . . , a1 −1 } is a module-Gröbner basis with respect
to the restriction to L(∞Q) of the order >u introduced in Sec.
III-C (which is independent of u). Note that −vQ (Je(c) ) = {s −
vQ ( i )|0 ≤ i < a1 , s ∈ S }. Then
deg x1 (LT( i )) = dimF L(∞Q)/Je(c) = wt(e(c)).
(6)

and
and
that

0≤ j<a1

bi, j y j , with ai, j , bi, j ∈ Fq [x1 ],
0≤ j<a1
0≤ j<a1
let νi(s) = LC(di,i ). We assume that LT( fi(s) ) = ai,i yi z
LT(g(s) ) = di,i yi . By [14, Lemmas 2,3,4], one has
i

fi(s) =

ai, j y j z +

deg(ai,i ) +
0≤i<a1
−vQ (ai,i yi ) ≤

deg(di,i ) = n,
0≤i<a1

and
−vQ ( i ) and −vQ (di,i yi ) ≤ −vQ (ηi ) or,
equivalently, deg(ai,i ) ≤ deg x1 (LT( i )) and deg(di,i ) ≤
deg x1 (LT(ηi )), for 0 ≤ i < a1 .
For 0 ≤ i < a1 , there are unique integers 0 ≤ i < a1 and
ki satisfying
−vQ (ai,i yi ) + s = a1 ki − vQ (yi ).
Note that by the deﬁnition above
i = i + s mod a1 ,
(8)
and the integer −vQ (ai,i yi ) + s is a nongap if and only
if ki ≥ 0. Now let ci = deg x (di ,i ) − ki . Note that the
map i → i is a permutation of {0, 1, . . . , a − 1} and that
the integer ci is deﬁned such that a1 ci = −vQ (di ,i yi ) +
vQ (ai,i yi ) − s.
3) Voting: For each i ∈ {0, . . . a1 − 1}, we set
bi,i [xki ]
, ci = max{ci , 0}.
¯
µi = LC(ai,i yi ϕ s ), wi = −
µi
We remark that the leading coeﬃcient µi must be considered after expressing ai,i yi ϕ s by monomials in Ω0 .
Let
1
ν(s) =
max{−vQ (ηi ) + vQ (yi ) − s, 0}.
(9)
a1 0≤i<a
1
The error correction capability of the algorithm will be
determined by the values ν(s). The number ν(s) was
introduced in [14, Proposition 10], we will show in
Proposition 4 that it is equivalent to the cardinality of
some sets introduced in [3] for bounding the minimum

0≤i<a1

Before describing the algorithm, we remark that its correctness is based in a straightforward generalization of some
results in [14, Sec. III-A]. In particular, we will directly refer
to these results in the description of the algorithm, because

3

iteration in this algorithm shrinks, where Γ(s) = {s ∈
Γ | s ≤ s}, while the number of errors remains the
same, at some point its minimum distance becomes
relatively large compared to the number of errors. Then
fmin should provide the codeword by −α0 /α1 . Actually,
this phenomenon has also been veriﬁed by our computer
experiments in Sec. IV-D.
Hence, we propose the following earlier termination
criterion: Let dAG (CΓ ) = min s∈Γ ν(s) be the bound for
the minimum distance in [3]. If dAG (CΓ(prec(s)) ) > 2τ, then
check whether α0 /α1 ∈ L(∞Q), ev(−α0 /α1 ) ∈ CΓ(prec(s))
and










w s ϕ s ) − r ≤ τ.
wt ev(−α0 /α1 +





distance.
We consider two diﬀerent candidates depending on
whether s ∈ Γ or not:
• If s ∈ S \ Γ, set w = 0.
• If s ∈ Γ, let w be the element of Fq with
ci ≥
¯
ci − 2τ + ν(s),
¯
(10)
w=wi

w wi

since by Proposition 5 we will have that
ci ≥
¯
ci − 2wt(e ) + ν(s),
¯
wi =ω s

wi ω s

where ω s and e are as deﬁned at Eq. (7).
Let w s = w. If several w’s satisfy the condition above,
repeat the rest of the algorithm for each of them. As s
decreases, ν(s) increases and at some point we have 2τ <
ν(s) and at that point at most one w veriﬁes condition
(10).
An interesting diﬀerence to the Feng-Rao majority voting is as follows: In the Feng-Rao voting, when wt(e)
is large, voting for the correct codeword can disappear,
i.e., there can be no vote for the correct codeword. In
contrast to this, in the Gröbner based majority voting, the
correct codeword always has a vote, because Ir contains
all the possible codewords and errors.
4) Rebasing: We consider the automorphism of L(∞Q)[z]
given by z → z + wϕ s that preserves the leading terms
with respect to > s . Hence B(s) is mapped to a set which is
a Gröbner basis of { f (z + wϕ s ) | f ∈ Ir(s) } with respect to
> s . However, this set is not (in general) a Gröbner basis
with respect to >prec(s) , which will be used in the next
iteration. Thus, we will update it, for each i ∈ {0, . . . a1 −
1}:
• If wi = w, then let
(prec(s))
gi
= g(s) (z + wϕ s ),
i
(prec(s))
fi
= fi(s) (z + wϕ s ),
where the parentheses denote substitution of the
(prec(s))
variable z and let νi
= νi(s) .
• If wi
w and ci > 0, then let
(prec(s))
gi
= fi(s) (z + wϕ s )
(prec(s))
fi
= xci fi(s) (z + wϕ s ) − µi (w−wi ) g(s) (z + wϕ s )
i
ν(s)
i

(prec(s))

•

s≤s ∈Γ

If the previous statement holds, include ev(−α0 /α1 +
s≤s ∈Γ w s ϕ s ) into the list of codewords, and avoid
proceeding with prec(s). Otherwise, iterate the procedure
with prec(s).
The procedure above is based on the following observations:
• If there exists a codeword c ∈ C Γ(prec(s)) with Hamming distance ≤ τ from r(prec(s)) , then, by Proposition
5, executing the iteration on Ir(prec(s)) gives the only
codeword c as the list of codewords, corresponding
to −α0 /α1 . Therefore, iterations with lower s are
meaningless.
• It was proved in [5, Lemmas 2.3 and 2.4], that if
2wt(ev(β)−r(prec(s)) )+2g < n−s then β must appear as
−α0 /α1 . Then we can terminate the algorithm at latest s = max{s | 2τ + 2g < n − s}. Because, under this
assumption, any other codeword ev(β ) ∈ CΓ(prec(s))
gives −α0 /α1 with −vQ (α1 ) > −vQ (α1 ), hence β
cannot correspond to fmin . Note that the genus zero
case was proved in [2, Theorem 12].
6) Termination: After reaching s = max{s | 2τ + 2g < n −
s} or after verifying the earlier termination condition,
include the recovered message (w s1 , w s2 , . . . , w sk ) in the
output list.
B. Relation of ν(s) to [3]
In [14], ν(s) was introduced in the same way as in Eq. (9).
We claim that ν(s) is equivalent to the sets used in [3], [9] for
bounding the minimum distance. Let Γindep as in Eq. (4). Let
S indep = {u | Cu Cu−1 }. Deﬁne
λ(s) = |{ j ∈ S | j + s ∈ S indep }|.
(11)
The bound in [3, Propositions 27 and 28] for the minimum
distance of CΓ is
dAG (CΓ ) = min{λ(s) | s ∈ Γ} ≥ n − sk .
The following proposition implies that du = min{ν(s) | s ∈
S , s ≤ u} is equivalent to dAG (Cu ), and therefore [3, Theorem
8] implies [14, Proposition 12].
Proposition 4: Let s ∈ S , one has that ν(s) = λ(s).
C. Proof and error correction capability of the algorithm
We will prove in this section the correctness and error
correction capability of the algorithm. Using [14, Lemmas 6,7
and Proposition 8] we have the following proposition that is
an extension of [14, Proposition 10].
Proposition 5: Let λ(s) = ν(s) as in Eqs. (9) and (11). We
have
ci ≥
¯
ci − 2wt(e(c)) + λ(s).
¯

and let νi
= µi (w − wi ).
If wi w and ci ≤ 0, then let
(prec(s))
gi
= gi(s) (z + wϕ s )
(prec(s))
fi
= fi(s) (z + wϕ s ) − µi (w−wi ) x−ci g(s) (z + wϕ s )
i
ν(s)
(prec(s))

i

and let νi
= νi(s) .
By [14, proposition 5] we have that
(prec(s))
(prec(s))
B(prec(s)) = {gi
, fi
| 0 ≤ i < a1 },
is a Gröbner basis of { f (z + wϕ s ) | f ∈ Ir(s) } = Ir(prec(s))
with respect to >prec(s) , where r(prec(s)) = r(s) − ev(wϕ s ).
We remark that the new Gröbner basis B(prec(s)) must be
considered after expressing it by monomials in Ω1 .
5) Earlier termination: The module Ir is a curve theoretic
generalization of the genus zero case considered in [2,
Deﬁnition 9]. Let fmin = α0 + zα1 having the smallest
(prec(s))
(prec(s))
−vQ (α1 ) among f0
, . . . , fa1 −1 . When the genus
is zero and the number of errors is less than half
the minimum distance, we can immediately ﬁnd the
codeword by −α0 /α1 [2, Theorem 12].
Besides, as s decreases, the code CΓ(s) treated by each

wi =ω s

4

wi ω s

One has that the set B(s) is a Gröbner basis of the Fq [x1 ]module Ir(s) with respect to > s by [14, Proposition 11] and
combining this with Proposition 5, we obtain the error correction capability of the algorithm in Sec. IV-A as a unique
decoding algorithm. Moreover, it a list-decoding algorithm
with error bound τ by Eq. (10).
Theorem 6: Let r = c + e(c). If wt(e(c)) ≤ τ then c is in
the output list of the algorithm in Sec. IV-A. If 2wt(e(c)) <
dAG (CΓ ) then w s = ω s for all s ∈ Γ and
w s ϕ s = µ,

Research (A) No. 23246071, the Villum Foundation through
their VELUX Visiting Professor Programme 2011–2012, the
Danish National Research Foundation and the National Science Foundation of China (Grant No.11061130539) for the
Danish-Chinese Center for Applications of Algebraic Geometry in Coding Theory and Cryptography and by Spanish grant
MTM2007-64704.
References
[1] W. W. Adams and P. Loustaunau, An Introduction to Gröbner Bases,
ser. Graduate Studies in Mathematics.
Providence, RI: American
Mathematical Society, 1994, vol. 3.
[2] M. Ali and M. Kuijper, “A parametric approach to list decoding of
Reed-Solomon codes using interpolation,” IEEE Trans. Inform. Theory,
vol. 57, no. 10, pp. 6718–6728, Oct. 2011, arXiv:1011.1040.
[3] H. E. Andersen and O. Geil, “Evaluation codes from order domain
theory,” Finite Fields Appl., vol. 14, no. 1, pp. 92–123, Jan. 2008.
[4] P. Beelen and K. Brander, “Eﬃcient list decoding of a class of algebraicgeometry codes,” Adv. Math. Commun., vol. 4, no. 4, pp. 485–518, 2010.
[5] P. Beelen and T. Høholdt, “The decoding of algebraic geometry codes,”
in Advances in Algebraic Geometry Codes, ser. Coding Theory and
Cryptology, E. Martínez-Moro, C. Munuera, and D. Ruano, Eds. World
Scientiﬁc, 2008, vol. 5, pp. 49–98.
[6] G. L. Feng and T. R. N. Rao, “Improved geometric Goppa codes part
I, basic theory,” IEEE Trans. Inform. Theory, vol. 41, no. 6, pp. 1678–
1693, Nov. 1995.
[7] O. Geil, R. Matsumoto, and D. Ruano, “List decoding algorithm
based on voting in Gröbner bases for general one-point AG codes,”
arXiv:1203.6127, Apr. 2012.
[8] ——, “Generalization of the Lee-O’Sullivan list decoding for one-point
AG codes,” arXiv:1203.6129, Apr. 2012.
[9] O. Geil, C. Munuera, D. Ruano, and F. Torres, “On the order bounds for
one-point AG codes,” Adv. Math. Commun., vol. 5, no. 3, pp. 489–504,
2011.
[10] O. Geil and R. Pellikaan, “On the structure of order domains,” Finite
Fields Appl., vol. 8, no. 3, pp. 369–396, Jul. 2002.
[11] G.-M. Greuel, G. Pﬁster, and H. Schönemann, “Singular 3.0,” Centre for
Computer Algebra, University of Kaiserslautern, A Computer Algebra
System for Polynomial Computations, 2005. [Online]. Available:
http://www.singular.uni-kl.de
[12] V. Guruswami and M. Sudan, “Improved decoding of Reed-Solomon
and algebraic-geometry codes,” IEEE Trans. Inform. Theory, vol. 45,
no. 4, pp. 1757–1767, Sep. 1999.
[13] K. Lee, “Unique decoding of plane AG codes revisited,”
arXiv:1204.0052, Mar. 2012.
[14] K. Lee, M. Bras-Amorós, and M. E. O’Sullivan, “Unique decoding of
plane AG codes via interpolation,” 2012, IEEE Trans. Inform. Theory,
Early Access. [Online]. Available: http://dx.doi.org/10.1109/TIT.2012.
2182757, arXiv:1110.6251.
[15] K. Lee and M. E. O’Sullivan, “List decoding of Hermitian codes using
Gröbner bases,” J. Symbolic Comput., vol. 44, no. 12, pp. 1662–1675,
Dec. 2009, arXiv:cs/0610132.
[16] J. B. Little, “List decoding for AG codes using Gröbner bases,” presented
at SIAM Conference on Applied Algebraic Geometry, North Carolina
State University, NC, USA, Oct. 2011.
[17] R. Matsumoto and S. Miura, “Finding a basis of a linear system with
pairwise distinct discrete valuations on an algebraic curve,” J. Symbolic
Comput., vol. 30, no. 3, pp. 309–323, Sep. 2000.
[18] ——, “On construction and generalization of algebraic geometry
codes,” in Proc. Algebraic Geometry, Number Theory, Coding Theory,
and Cryptography, T. Katsura et al., Eds., Univ. Tokyo, Japan,
Jan. 2000, pp. 3–15. [Online]. Available: http://www.rmatsumoto.org/
repository/weight-construct.pdf
[19] S. Miura, “Algebraic geometric codes on certain plane curves,” Electronics and Communications in Japan (Part III: Fundamental Electronic
Science), vol. 76, no. 12, pp. 1–13, Dec. 1993.
[20] ——, “Linear codes on aﬃne algebraic curves,” Trans. IEICE, vol. J81A, no. 10, pp. 1398–1421, Oct. 1998 (Japanese).
[21] K. Saints and C. Heegard, “Algebraic-geometric codes and multidimensional cyclic codes: A uniﬁed theory and algorithms for decoding using
Gröbner bases,” IEEE Trans. Inform. Theory, vol. 41, no. 6, pp. 1733–
1751, Nov. 1995.
[22] L.-Z. Tang, “A Gröbner basis criterion for birational equivalence of aﬃne
varieties,” J. Pure Appl. Algebra, vol. 123, pp. 275–283, Jan. 1998.

s∈Γ

where µ and ω s ’s are as deﬁned at Eq. (5).
D. Computer experiments: Comparison against GuruswamiSudan algorithm
We implemented the proposed list decoding algorithm on
Singular [11] and decoded 1,000 randomly generated codewords with the following conditions. Firstly we used the onepoint primal code Cu with u = 20 on the Klein quartic over
F8 . It is [23, 18] code and its AG bound [3] is 4 while Goppa
bound is 3. Guruswami-Sudan decoding can decode up to 1.
Our algorithm can list all the codewords within Hamming
distance 2. The errors were uniformly randomly generated
among the vectors with Hamming weight 2 and executed the
decoding algorithm with τ = 2. With 757 transmissions the list
size was 1, with 180 transmissions the list size was 2, and with
63 transmissions the list size was 3, where the list size means
the number of codewords whose Hamming distance from the
received word is ≤ τ. The maximum number of iterations was
266, the minimum was 11, the average was 195.7, and the
standard deviation was 60.5.
Secondly we used the improved code construction [6] with
the designed minimum distance 6. It is a [64, 55] code. In order
to have the same dimension by Cu we have to set u = 60,
whose AG bound [3] is 4 and the Guruwsami-Sudan can
correct 2 errors. The proposed algorithm ﬁnds all codewords
in the improved code with 3 errors. The errors were uniformly
randomly generated among the vectors with Hamming weight
3. With 998 transmissions the list size was 1, and with 2
transmissions the list size was 2. The maximum number of
iterations was 1128, the minimum was 14, the average was
794.2, and the standard deviation was 179.8.
Thirdly we used the same code as the second experiment,
while the errors with Hamming weight 3 were randomly generated toward another nearest codeword. With 901 transmissions
the list size was 2, and with 99 transmissions the list size was
5. The maximum number of iterations was 818, the minimum
was 196, the average was 754.5, and the standard deviation
was 185.3. Observe that the list size cannot become 1 under
this condition, and the simulation conﬁrmed it.
V. Conclusion
We generalized the two decoding algorithms [15], [14] to all
algebraic curves. We also extend the latter algorithm [14] to
a list decoding one. The resulted list decoding algorithm can
correct more errors than the Guruswami and Sudan algorithm
[12]. The detailed analysis of the computational complexity of
the latter one is a future research agenda.
Acknowledgments
The authors would like to thank an anonymous reviewer for
pointing out errors in the initial manuscript. This research was
partially supported by the MEXT Grant-in-Aid for Scientiﬁc

5

