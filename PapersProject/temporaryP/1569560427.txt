Creator:         TeX output 2012.05.03:1931
Producer:       Appligent StampPDF Batch, version 5.1
CreationDate:   Thu May  3 19:31:31 2012
ModDate:        Tue Jun 19 12:54:10 2012
Tagged:         no
Pages:          5
Encrypted:      no
Page size:      612 x 792 pts (letter)
File size:      290662 bytes
Optimized:      no
PDF version:    1.6
ISIT'2012 1569560427

Burst List Decoding of Interleaved Reedâ€“Solomon
Codes
Tom Kolan and Ron M. Roth
Computer Science Department, Technion, Haifa 32000, Israel.
tomkolan@gmail.com, ronny@cs.technion.ac.il
c âˆˆ C and e âˆˆ B(n, Ï„ ),

Abstractâ€”It is shown that interleaved Reedâ€“Solomon codes can
be list-decoded for burst errors while attaining the generalized
Reiger bound for list decoding.

e âˆˆ D(c + e) .
Equivalently, for every y âˆˆ F n ,

I. I NTRODUCTION

(y âˆ’ C) âˆ© B(n, Ï„ ) âŠ† D(y) .

Coding schemes for list decoding of isolated (random)
errorsâ€”especially schemes that are based on Reedâ€“Solomon
codes and derivatives thereofâ€”have been studied quite extensively [2]â€“[6]. Less, however, has been published about list
decoding of burst errors. In a recent paper [7], several bounds
were obtained on the parameters of list decodable codes for
single bursts. It was also shown there that Reedâ€“Solomon
codes attain these bounds. We will review some of the results
of [7] below, after introducing some deï¬nitions and notation.
Throughout this work, we let F denote the ï¬nite ï¬eld
GF(q). The order of an element Î³ in the multiplicative group
F âˆ— will be denoted by O(Î³). For integers i < j, the notation
[i, jâŸ© stands for the integer interval {k âˆˆ Z : i â‰¤ k < j}.
We say that a word e âˆˆ F n is a Ï„ -burst if either e = 0 (the
all-zero word) or the indexes i and j (in [0, nâŸ©) of the ï¬rst and
last nonzero entries in e satisfy j âˆ’ i < Ï„ . For a nonzero word
e, the notation Î»(e) will stand for the value of i above, and
the value j âˆ’ i + 1 will be referred to as the (actual) length of
the Ï„ -burst and will be denoted by L(e) (where L(0) = 0).
The set of all Ï„ -bursts in F n will be denoted by B(n, Ï„ ).
For a code C of length n over F and a word y âˆˆ F n , we
denote by y âˆ’ C the set {y âˆ’ c : c âˆˆ C} (when C is linear,
this set is a coset of C within F n ). The minimum (Hamming)
distance of C will be denoted by d(C).
Let C be a code of length n over F . A (list) decoder for C
is a mapping D from F n to the set of subsets of F n , such that
D(y) âŠ† y âˆ’ C for every y âˆˆ F n (we knowingly deviate here
from the standard deï¬nition of a decoder in that D returns a
list of error words rather than codewords). The list size of a
decoder D is the largest size of D(y) over all y âˆˆ F n .
We say that D detects any single Ï„ -burst error if for every
c âˆˆ C and e âˆˆ B(n, Ï„ ),
{
{0}
if e = 0
D(c + e) =
.
âˆ…
otherwise

(1)

An (â„“, Ï„ )-burst list decoder for C is a decoder for C of list
size at most â„“ that corrects any single Ï„ -burst error. From (1),
it readily follows that such a decoder exists if and only if for
every y âˆˆ F n ,
|(y âˆ’ C) âˆ© B(n, Ï„ )| â‰¤ â„“ .
The following generalization of the Reiger bound (specialized to linear codes) was recently proved in [7].
Theorem 1.1 ([7, Thms. 2.2â€“2.3]): Let C be a linear code
of length n over F and let Ï„ and â„“ be positive integers that
satisfy the following three conditions:
1) Either (â„“+1)Ï„ â‰¤ n, or â„“ | Ï„ and 2Ï„ â‰¤ n.
2) There is a decoder for C that detects any single Ï„ -burst
error.
3) There is an (â„“, Ï„ )-burst list decoder for C.
Then the redundancy r of C satisï¬es the lower bound
r â‰¥ Ï„ + âŒˆÏ„ /â„“âŒ‰ .
Conversely, it was also shown in [7] that shortened Reedâ€“
Solomon codes (in short, RS codes) attain this bound.
Theorem 1.2 ([7, Thm. 4.1]): For 0 â‰¤ r < n < q, let
CRS (n, r) denote the RS code of length n and redundancy
r over F with a parity-check matrix
(
)râˆ’1 nâˆ’1
HRS = HRS (n, r) = Î±st s=0, t=0 ,
(2)
where Î± âˆˆ F âˆ— with O(Î±) â‰¥ n. There is an (â„“, Ï„ )-burst list
decoder for CRS (n, r), whenever â„“ and Ï„ are positive integers
that satisfy
âŒˆÏ„ âŒ‰
.
râ‰¥Ï„+
â„“
(Note that condition 2 in Theorem 1.1 is also satisï¬ed in this
case, since d(CRS ) = r + 1 > Ï„ .)
One drawback of RS codes is that their length is limited to
at most q âˆ’ 1. In this work, we show that for the case where
â„“ divides Ï„ , the bound of Theorem 1.1 is attained also by a
(Ï„ /â„“)-level interleaving of CRS (n, â„“+1), thereby introducing
optimal codes that are Ï„ /â„“ times longer (for â„“ = 1, this
result is straightforward and well known). Furthermore, we
demonstrate that interleaved RS codes can be list-decoded for

Such a decoder for C exists if and only if (c âˆ’ C) âˆ© B(n, Ï„ ) =
{0} for every c âˆˆ C. In particular, such a decoder exists if
d(C) > Ï„ .
We say that D corrects any single Ï„ -burst error if for every

1

Then D is an (â„“, â„“)-burst list decoder for CRS (n, r), and the
following inequality is satisï¬ed for every y âˆˆ F n \ CRS (n, r):
âˆ‘
(â„“ + 1 âˆ’ L(e)) â‰¤ â„“ .

bursts using an algorithm that is (signiï¬cantly) more efï¬cient
than a burst list decoder for a non-interleaved RS code with
comparable parameters. To show that the interleaving indeed
works, we prove a reï¬nement of Theorem 1.2 for the case
Ï„ = â„“. Finally, we show through an example that, unlike the
special case of RS codes, interleaving does not always preserve
the list-decoding properties of the constituent code.

eâˆˆD(y)

Our proof of Theorem 2.2 will use the following lemma.
Lemma 2.3: For integers 0 < â„“ < n < q, let CRS =
CRS (n, â„“+1) be as deï¬ned in Theorem 1.2 and let

II. T OOLS
In this section, we consider the case Ï„ = â„“ and prove that
the (â„“, â„“)-burst list decoder D guaranteed in Theorem 1.2 can
be assumed to satisfy a certain relationship between the size
of each list D(y) and the lengths of the bursts in D(y).
This relationship will then be used in Section III to show
that interleaved RS codes attain the bound of Theorem 1.1.
We recall the next theorem from [7], which will be used in
the sequel; hereafter, FÎ´ [x] denotes the set of all univariate
polynomials of degree less than Î´ over F in the indeterminate
x.
Theorem 2.1 ([7, Thm. 3.1]): For integers 1 < m â‰¤ r < q,
let Î²0 , Î²1 , . . . , Î²mâˆ’1 be elements in F âˆ— and let Î³ âˆˆ F âˆ— be
such that O(Î³) â‰¥ r. Also, let Âµ0 , Âµ1 , . . . , Âµmâˆ’1 be positive
integers such that
mâˆ’1
âˆ‘
Âµi = r ,

e0 , e1 , . . . , emâˆ’1
be words in B(n, â„“), all belonging to the same nontrivial coset
y âˆ’ CRS (where y Ì¸âˆˆ CRS ). Then
mâˆ’1
âˆ‘

(â„“ + 1 âˆ’ L(ei )) â‰¤ â„“ .

(4)

i=0

In particular, m â‰¤ â„“.
Proof: The proof builds upon the one given in [7] for
Theorem 1.2 but requires additional arguments in order to get
to the ï¬ner result. We will assume in the proof that n = O(Î±)
(otherwise, append O(Î±) âˆ’ n zeroes to each ei and apply the
proof to CRS (O(Î±), â„“+1)).
For i âˆˆ [0, mâŸ©, write
Î»i = Î»(ei ) ,

Ï„i = L(ei ) ,

and

Âµi = â„“ + 1 âˆ’ Ï„i ;

(5)

i=0

note that the support of ei is contained in the set

and, for each i âˆˆ [0, mâŸ©, deï¬ne the polynomial
Mi (x; Î²i , Î³) =

râˆ’1âˆ’Âµi
âˆ

(x âˆ’ Î²i Î³ t )

Ji = [Î»i , Î»i +Ï„i âŸ© .
(6)
âˆ‘mâˆ’1
We need to show that i=0 Âµi â‰¤ â„“.
âˆ‘mâˆ’1
Suppose to the contrary that i=0 Âµi â‰¥ â„“ + 1. Without
real loss of generality, we will assume hereafter in the proof
that the latter inequality holds with equality; otherwise, we
can increase some of the Ï„i â€™s (effectively replacing some of
the actual burst lengths by upper bounds on these lengths) and
decrease the respective values of Âµi (= â„“+1âˆ’Ï„i ) accordingly,
to achieve the equality

(3)

t=0

(which is regarded as a univariate polynomial in the indeterminate x, with Î²i and Î³ serving as parameters). The following
two conditions are equivalent:
(i) There exist polynomials
ui (x) âˆˆ FÂµi [x],

i âˆˆ [0, mâŸ© ,

not all zero, such that
mâˆ’1
âˆ‘

mâˆ’1
âˆ‘

ui (x)Mi (x; Î²i , Î³) = 0 .

Âµi = â„“ + 1 .

(7)

i=0

i=0

(ii) For some distinct h, k âˆˆ [0, mâŸ© and some integer b in the
range âˆ’Âµh < b < Âµk ,
Î²k
= Î³b .
Î²h
Next, we state a reï¬nement of Theorem 1.2 for the case
Ï„ = â„“: we provide a stronger property of the guaranteed list
decoder D therein, in terms of the lengths of the decoded
bursts. Namely, if one or more of the decoded bursts turns
out to have actual length that is (strictly) smaller than â„“, then
such â€œdeï¬ciencyâ€ in the burst length implies that the size of
the decoded list size must, in fact, be (strictly) smaller than â„“.
Theorem 2.2: For integers 0 < â„“ < r < n < q, let
CRS (n, r) be as in Theorem 1.2, and let the decoder D for
CRS (n, r) be deï¬ned for every y âˆˆ F n by
(
)
D(y) = y âˆ’ CRS (n, r) âˆ© B(n, â„“) .

For i âˆˆ [0, mâŸ©, let
Mi (x) = Mi (x; Î±Î»i , Î±) =

Ï„i âˆ’1
âˆ

(x âˆ’ Î±Î»i +t )

(8)

t=0

be the specialization of (3) to Î³ = Î±, Î²i = Î±Î»i , r = â„“ + 1, and
Âµi as in (5). The next steps in our proof are very similar to
the proof of Theorem 1.2 in [7], with r and â„“ therein replaced
by â„“ + 1 and m âˆ’ 1, respectively. It follows from the analysis
in [7, p. 4189] (details omitted) that there exist polynomials
ui (x) âˆˆ FÂµi [x] ,

i âˆˆ [0, mâŸ© ,

(9)

not all zero, such that
mâˆ’1
âˆ‘
i=0

2

ui (x)Mi (x) = 0 .

(10)

Codeword of CRS (n, â„“+1)

Combining (7)â€“(10) with Theorem 2.1, we conclude that
there exist distinct h, k âˆˆ [0, mâŸ© and some integer b in the
range âˆ’Âµh < b < Âµk such that

0

namely,
(mod n) ,


Fig. 1.

=
<

(12)

â‰¤

Ï„ /â„“

-

Interleaved array, with a Ï„ -burst error marked by the shaded area.

namely, it consists of all n Ã— (Ï„ /â„“) arrays over F whose
columns are codewords cj of CRS = CRS (n, â„“+1). When
transmitted over a noisy channel, the array is sent row by row,
in which case a Ï„ -burst error is seen as â„“-burst errors in the
columns of the array, as shown in Figure 1. The shaded area
in the ï¬gure represents a largest possible set of entries that can
be affected by a single Ï„ -burst: generally, entries in that area
(including leading or trailing entries) can still be error-free,
in which case some columns in the array may incur bursts of
length less than â„“. While this observation is straightforward, it
is those lightly corruptedâ€”yet still corruptedâ€”columns that
could potentially fail the decoding of the array by requiring
the list size to be greater than â„“. Indeed, this could happen
if CRS were replaced by an arbitrary constituent code C, even
when C is (â„“, â„“)-burst list decodable and d(C) â‰¥ â„“ + 2 (see
Example 4.1 below). However, as we show, Theorem 2.2 will
guarantee decoding success for C when C = CRS .
The following theorem is the main result of this paper.
Theorem 3.1: Given positive integers â„“ â‰¤ Ï„ < n < q
such that â„“ | Ï„ , let C be the (Ï„ /â„“)-level interleaving of CRS =
CRS (n, â„“+1). Then C has an (â„“, Ï„ )-burst list decoder. In
particular, C attains the bound of Theorem 1.1 when 2â„“ â‰¤ n.
We will prove Theorem 3.1 by introducing an (â„“, Ï„ )-burst
list decoding algorithm for C. The algorithm is presented in
Figure 2, and the remaining part of this section is devoted to
analyzing that algorithm.
The input to the algorithm is an n Ã— (Ï„ /â„“) array Y over
F , which is assumed to be a copy of a code array of C,
possibly corrupted by a Ï„ -burst error. The algorithm consists
of three main loops: (A), (B), and (C). Loop (A) iterates over
the columns of Y , as long as the columns are codewords of
CRS . If Y is found to be error-free, then loops (B) and (C) are
skipped, and the algorithm returns a list of size 1, containing
the all-zero n Ã— (Ï„ /â„“) array.
When Y is ï¬‚agged with errors, Loop (B) is entered with the
index j pointing at the ï¬rst column, yj , in Y that is corrupted.
The (â„“, â„“)-burst list decoder D of Theorem 2.2 is applied to
that column, resulting in the list
(
)
D(yj ) = yj âˆ’ CRS âˆ© B(n, â„“) = {e0 , e1 , . . . , emâˆ’1 } .

(12)

and, so,
(13)

6
â„“
?

nâˆ’1

On the other hand, since eh and ek are distinct yet belong to
the same coset of CRS , the difference eh âˆ’ ek is a nonzero
codeword of CRS and, as such, its Hamming weight is at least
â„“ + 2. Hence,
|Jh âˆª Jk | > â„“ + 1
(13)
Âµk

R

.
.
.

(11)

where we have used our assumption that n = O(Î±). Without
loss of generality we can assume further that 0 â‰¤ b (< Âµk ), or
else simply switch between the roles of h and k. Also, since
CRS is cyclic when n = O(Î±), we can rotate the ei â€™s, all by
the same number Ï of positions, and the resulting new words
will all belong to the same coset of CRS . We should then add,
modulo n, the integer Ï to each Î»i (and, respectively, to each
index in each set Ji in (6)), to obtain the correct index values
for the rotated words. Thus, (11) still holds (for the same b)
regardless of the value of Ï; in particular, we can select Ï so
that (0 â‰¤) Î»h â‰¤ Î»k (< n).
Doing so, we get that
|Jh \ Jk | â‰¤ Î»k âˆ’ Î»h = b .

â€œStepâ€

2

Î±Î»k âˆ’Î»h = Î±b ;
Î»k âˆ’ Î»h â‰¡ b



1

â„“ + 1 âˆ’ Ï„k
|Jh âˆª Jk | âˆ’ |Jk | = |Jh \ Jk |
Î»k âˆ’ Î»h = b ,

thereby contradicting the fact that b < Âµk .
Remark 2.1: It can be shown (by counterexamples) that
Lemma 2.3 would no longer hold if we attempted to generalize
it to arbitrary linear codes that attain the bound of Theorem 1.1
for Ï„ = â„“, not even when the codes are MDS.
Proof of Theorem 2.2: First, D is a decoder that corrects
any single â„“-burst, since it satisï¬es the containment (1) (with
equality) for Ï„ = â„“. Now, since r â‰¥ â„“+1, we have CRS (n, r) âŠ†
CRS (n, â„“+1) and, so, for every y âˆˆ F n ,
(
)
D(y) âŠ† y âˆ’ CRS (n, â„“+1) âˆ© B(n, â„“) .
For y Ì¸âˆˆ CRS (n, â„“+1), we get the result from Lemma 2.3,
(
while for y âˆˆ CRS (n, â„“+1) \ CRS (n, r), we have y âˆ’
)
CRS (n, r)) âŠ† CRS (n, â„“+1) \ {0}, which, in turn, implies that
the set D(y) is empty.
III. B URST L IST D ECODING OF INTERLEAVED RS C ODES
In this section, we show that when â„“ divides Ï„ , a (Ï„ /â„“)level interleaving of CRS (n, â„“+1) yields a code C that has an
(â„“, Ï„ )-burst list decoder. Speciï¬cally, the code C is deï¬ned by
{
C = C(n, â„“, Ï„ ) = (c0 |c1 | . . . |cÏ„ /â„“âˆ’1 ) :
}
cj âˆˆ CRS (n, â„“+1) for j âˆˆ [0, Ï„ /â„“âŸ© ;

Writing Î»i = Î»(ei ) and Ï„i = L(ei ), for each i âˆˆ [0, mâŸ©, the

3

beyond the array boundaries). Yet, we need to take into
account that row bâ€² âˆ’ 1 might also be part of the Ï„ -burst at
columns k > j, due to the â€œstepâ€ shown in Figure 1 (which
may occur if the Ï„ -burst does not start right at the beginning
of a row). Letting b = bâ€² âˆ’ 1, the result follows.
Lemma 3.3:
|S| â‰¤ â„“ .

Input: received array Y = (y0 |y1 | . . . |yÏ„ /â„“âˆ’1 ) over F .
Data structures:
Integer intervals V âŠ† [0, nâŸ©;
Set S of intervals V âŠ† [0, nâŸ©;
{ Arrays EV over F indexed by V âˆˆ S.

(

for ( â† 0; j < Ï„ /â„“; j++
j
)
if yj Ì¸âˆˆ CRS
} break;

(

){

(A)

Proof: Using the notation (14), we have

)

if j â‰¥ Ï„ /â„“
Output {0nÃ—(Ï„ /â„“) };
{
else
S â† âˆ…;
for every e âˆˆ D(yj )
(
for b = max(Î»(e)+L(e)âˆ’â„“, 0)âˆ’1;
){
b < min(Î»(e), nâˆ’â„“); b++
V â† [max(b, 0), b+â„“+1âŸ©;
S â† S âˆª {V };
EV â† (0nÃ—j |e);
}

(

)

for k â† j + 1; k { Ï„ /â„“; k++
<
for every V âˆˆ S
(
){
if DV (yk ) contains a word e and L(e) â‰¤ â„“
EV â† (EV |e);
(
)
if e Ì¸= 0 and V = [Î»(e), Î»(e)+â„“+1âŸ©
} V â† V \ {Î»(e)+â„“};

|S| â‰¤

i=0

(C)

} Output {EV : V âˆˆ S};

Fig. 2.

|Si | â‰¤

mâˆ’1
âˆ‘

(â„“ + 1 âˆ’ Ï„i ) â‰¤ â„“ ,

i=0

where the last inequality follows from Theorem 2.2.
Turning to Loop (C), this loop iterates over the remaining
columns in the array, and to each column, an erasure decoder
y â†’ DJ (y) for CRS is applied: given any subset J âŠ† [0, nâŸ©
and word y âˆˆ F n , the set DJ (y) consists of all words in the
coset y âˆ’ CRS whose support is contained in J. The subsets J
are taken as the intervals V âˆˆ S, and Lemma 3.2 guarantees
that the arrays EV that are formed in Loop (C) range over all
the Ï„ -bursts in the coset Y âˆ’C. Furthermore, since |V | â‰¤ â„“+1
for every V âˆˆ S, we get from the distance properties of CRS
that |DV (yk )| â‰¤ 1 for every k and V ; i.e., there is at most one
possible column e âˆˆ DV (yk ) that can be appended to each
EV while still forming (the ï¬rst k + 1 columns of) a Ï„ -burst.
Hence, by Lemma 3.3, the output list, {EV : V âˆˆ S}, has
size at most â„“. This completes the proof that the algorithm
in Figure 1 is an (â„“, Ï„ )-burst list decoder for C; namely, C
satisï¬es condition 3 in Theorem 1.1.
It is easy to see that C also satisï¬es condition 2; in
fact, Loop (A) can serve as a single (Ï„ + (Ï„ /â„“))-burst error
detector for C, where an early â€œbreakâ€ from the loop means
that at least one of the columns in Y has been subject to
an (â„“+1)-burst error. Our requirement that 2â„“ â‰¤ n implies
that C satisï¬es condition 1 in Theorem 1.1, and a simple
calculation shows that the redundancy of C is Ï„ + (Ï„ /â„“),
thereby attaining the bound of that theorem. This completes
the proof of Theorem 3.1.
Remark 3.1: The two â€œifâ€s in Loop (C) guarantee that the
returned list in Figure 2 contains only Ï„ -bursts. Speciï¬cally,
the outer â€œifâ€ will disqualify an interval V if the (unique) burst
error that is returned by the erasure decoder (at any column)
for that V has length â„“ + 1. And the inner â€œifâ€ guarantees that
once we incur the â€œstepâ€ in Figure 1, there will be no â€œstep
backâ€ in subsequent columns.

(B)

else
} S â† S \ {V };

}

mâˆ’1
âˆ‘

Decoding algorithm for C.

following collection of up to â„“ + 1 âˆ’ Ï„i integer intervals Vi,b
is added to the interval set S that is computed in Loop (B):
{
Si = Vi,b = [max(b, 0), b+â„“+1âŸ© :
}
max(Î»i +Ï„i âˆ’â„“, 0) âˆ’ 1 â‰¤ b < min(Î»i , nâˆ’â„“) . (14)
Next, we state two lemmas regarding the interval set S.
Lemma 3.2: Suppose that E is an n Ã— (Ï„ /â„“) array over F
that forms a Ï„ -burst when unfolded (as in Figure 1). Assume
in addition that E is in the coset Y âˆ’ C and that column j in
E equals one of the words in D(yj ). Then the nonzero entries
in E are all conï¬ned to rows that are indexed by one of the
intervals V âˆˆ S.
Proof: Suppose that column j in E equals ei âˆˆ D(yj ).
We show that the nonzero entries in E are conï¬ned to rows
that are indexed by one of the intervals Vi,b âˆˆ Si in (14).
The projection of the Ï„ -burst to column j forms an â„“-burst
that is indexed by an interval [bâ€² , bâ€² +â„“âŸ©, where

IV. D ISCUSSION
We start by computing the complexity of the decoding
algorithm in Figure 2.
Loop (A) can be carried out by computing the syndrome,
with respect to the parity-check matrix HRS = HRS (n, â„“+1)
in (2), of each column in the array Y (these syndromes will be
used also for columns j through Ï„ /â„“âˆ’1 in Loops (B) and (C)).
This computation requires less than 2(Ï„ /â„“) Â· (â„“+1)n = O(Ï„ n)
arithmetic operations in F .

max(Î»i +Ï„i âˆ’â„“, 0) â‰¤ bâ€² â‰¤ min(Î»i , nâˆ’â„“)
(the max(Â·, 0) and min(Â·, nâˆ’â„“) just truncate the lower and
upper limits so that the interval [bâ€² , bâ€² +â„“âŸ© does not extend

4

Loop (B) applies an (â„“, â„“)-burst list decoder for CRS (n, â„“+1)
to column j in Y . Such a decoder, in turn, can be implemented
by applying iteratively an erasure decoder DJ (Â·) to that
column, where J ranges over the intervals

aj the word in F n whose entries are all equal to aj , deï¬ne
the following â„“/2 subsets of F n (each of size â„“):
{
}
Cj = aj âˆ’ ei,j : i âˆˆ [0, â„“âŸ© , j âˆˆ [0, â„“/2âŸ© .
â„“/2âˆ’1

[b, b+â„“âŸ© ,

The code C is deï¬ned as the union âˆªj=0 Cj . It can be readily
veriï¬ed that d(C) = â„“ + 2: the distance between any two
distinct words within each subset Cj is â„“+2, while the distance
between any two words from distinct subsets is at least n âˆ’
(â„“ + 2) > 2â„“ â‰¥ â„“ + 2. In addition, C has an (â„“, â„“)-burst list
decoder: indeed, if the intersection (y âˆ’C)âˆ©B(n, â„“) contained
more than â„“ words, then at least two of them, say y âˆ’ cj and
y âˆ’ ck , had to correspond to codewords cj and ck that belong
to distinct subsets Cj and Ck . However, this is impossible,
since cj and ck , and hence y âˆ’ cj and y âˆ’ ck , differ on more
than 2â„“ positions and, therefore, cannot be both in B(n, â„“).
Let C be the code over F obtained by a (Ï„ /â„“)-level
interleaving of C, and consider the following n Ã— (Ï„ /â„“) array
over F :

b âˆˆ [0, nâˆ’â„“âŸ© .

Given yj âˆˆ F n , let S(x) be the syndrome polynomial in
Fâ„“+1 [x] that is associated with yj , namely, the coefï¬cients
of S(x) are given by the syndrome HRS yj . Also, for b âˆˆ
[0, nâˆ’â„“âŸ©, let Î›b (x) be the erasure-locator polynomial
Î›b (x) =

â„“âˆ’1
âˆ

(1 âˆ’ Î±b+t x) .

t=0

It follows from the known properties of RS decoding (see,
for example, [1]) that D[b,b+â„“âŸ© (yj ) Ì¸= âˆ… if and only if the
coefï¬cient of xâ„“ in the erasure evaluator polynomial,
Î“b (x) = Î›b (x)S(x) MOD xâ„“+1 ,

Y = (a0 |a1 | . . . |aâ„“/2âˆ’1 |0|0| . . . |0) .

is zero (where MOD denotes remaindering). And when that
happens, the erasure values can be found by Forneyâ€™s algorithm, namely, by evaluating the ratio âˆ’Î“b (x)/(xÎ›â€² (x)) at
b
x = Î±âˆ’b , Î±âˆ’bâˆ’1 , . . . , Î±âˆ’bâˆ’â„“+1 . The polynomials Î“b (x), in
turn, satisfy the relationship

When we apply an (â„“, â„“)-burst list decoder D for C to each
column of Y , we get, for the ï¬rst â„“/2 columns:
{
}
D(aj ) = aj âˆ’ Cj = e0,j , e1,j , . . . , eâ„“âˆ’1,j , j âˆˆ [0, â„“/2âŸ©
(for the remaining columns we get D(0) =({0}).
)
Next, for every (i, k) âˆˆ {(0, â„“/2âˆ’1)} âˆª [1, â„“âŸ© Ã— [0, â„“/2âŸ© ,
deï¬ne the n Ã— (Ï„ /â„“) array

Î“b+1 (x) = Î“b (x)(1 âˆ’ Î±b+â„“ x)/(1 âˆ’ Î±b x) MOD xâ„“+1 ;
as such, they can be all computed using O(â„“n) arithmetic
operations in F . Recalling that |(yj âˆ’ CRS ) âˆ© B(n, â„“)| â‰¤ â„“,
we will need to apply Forneyâ€™s algorithm at most â„“ times;
therefore, the overall time complexity of Loop (B) is O(â„“n +
â„“3 ) operations in F .
Loop (C) amounts to applying the RS erasure decoder DV (Â·)
at most |S| times to each of the remaining columns of Y . This,
(
)
in turn, can be carried out using O (Ï„ /â„“)|S|â„“2 = O(Ï„ â„“2 )
operations in F . Hence, the overall time complexity of the
(
)
algorithm in Figure 2 is O(Ï„ n + Ï„ â„“2 ) = O â„“(N + â„“Ï„ )
operations in F , where N = (Ï„ /â„“)n stands for the effective
length of C as a linear code over F .
Our strategy for implementing an (â„“, â„“)-burst list decoder
for CRS (n, â„“+1) (in the analysis of Loop (B)) can be applied
more generally to obtain an (â„“, Ï„ )-burst list decoder for
CRS (N, Ï„ + (Ï„ /â„“)). The resulting time complexity will then
(
)
be O Ï„ (N + â„“Ï„ ) operations in F , namely, Ï„ /â„“ times more
than the decoding complexity of an interleaved RS code of
the same length.
We conclude with the next example, where we present
a code C with d(C) = â„“ + 2 that has an (â„“, â„“)-burst list
decoder, yet the (Ï„ /â„“)-level interleaving of C is (â„“â€² , Ï„ )-burst
list decodable only for â„“â€² that grows quadratically with â„“.
Example 4.1: Let â„“ â‰¤ 2q be a positive even integer, let
Ï„ â‰¥ â„“2 /2 be a positive integer multiple of â„“, and let n
be an integer greater than (â„“+2)2 /2. For each i âˆˆ [0, â„“âŸ©
and j âˆˆ [0, â„“/2âŸ©, set ei,j to be a word in F n with support
[i(â„“/2+1) + j, (i+1)(â„“/2+1) + jâŸ© (of size â„“/2 + 1). Also, let
a0 , a1 , . . . , aâ„“/2âˆ’1 be â„“/2 distinct elements of F . Denoting by

Ei,k = (ei,0 |ei,1 | . . . |ei,k |eiâˆ’1,k+1 |eiâˆ’1,k+2 | . . .
|eiâˆ’1,â„“/2âˆ’1 |0|0| . . . |0) .
Clearly, Ei,k âˆˆ Y âˆ’ C. In addition, it can be veriï¬ed that each
Ei,k is a Ï„ -burst. Thus, we have shown that the number of
Ï„ -bursts in Y âˆ’ C is at least â„“(â„“âˆ’1)/2 + 1 (which is greater
than â„“ when â„“ â‰¥ 4).
ACKNOWLEDGMENT
The authors wish to thank Pascal Vontobel for his helpful comments. This work was supported in part by Grant
No. 1280/08 from the Israel Science Foundation.
R EFERENCES
[1] R.E. Blahut, Theory and Practice of Error Control Codes, AddisonWesley, Reading, Massachusetts, 1983.
[2] P. Elias, â€œError-correcting codes for list decoding,â€ IEEE Trans. on
Inform. Theory, 37 (1991), 5â€“12.
[3] V. Guruswami, A. Rudra, â€œExplicit codes achieving list decoding capacity: error-correcting with optimal redundancy,â€ IEEE Trans. Inform.
Theory, 54 (2008), 135â€“150.
[4] V. Guruswami, M. Sudan, â€œImproved decoding of Reedâ€“Solomon and
algebraicâ€“geometry codes,â€ IEEE Trans. Inform. Theory, 45 (1999),
1757â€“1767.
[5] R. Koetter, A. Vardy, â€œAlgebraic soft-decision decoding of Reedâ€“Solomon
codes,â€ IEEE Trans. Inform. Theory, 49 (2003), 2809â€“2825.
[6] F. Parvaresh, A. Vardy, â€œCorrecting errors beyond the Guruswamiâ€“Sudan
radius in polynomial time,â€ Proc. 46th Annual IEEE Symp. Foundations
of Computer Science (FOCS 2005), Pittsburgh, PA (2005), 285â€“294.
[7] R.M. Roth, P.O. Vontobel, â€œList decoding of burst errors,â€ IEEE Trans.
Inform. Theory, 55 (2009), 4179â€“4190.

5

