Creator:         TeX output 2012.05.18:1636
Producer:       Appligent StampPDF Batch, version 5.1
CreationDate:   Fri May 18 16:37:03 2012
ModDate:        Tue Jun 19 12:55:31 2012
Tagged:         no
Pages:          5
Encrypted:      no
Page size:      612 x 792 pts (letter)
File size:      336802 bytes
Optimized:      no
PDF version:    1.6
ISIT'2012 1569566497

Binary Graphs and Message Passing Strategies for
Compressed Sensing in the Noiseless Setting
Francisco Ramirez-Javega, Meritxell Lamarca, Javier Villares
Signal Processing and Communications Group,
Department of Signal Theory and Communications (TSC)
Universitat Politecnica de Catalunya (UPC)
Email: javega@tsc.upc.edu, meritxell.lamarca@upc.edu, javier.villares@upc.edu
measurement matrices were shown to outperform ğ‘™1 -based
theoretical limits, e.g. the scheme proposed in [9].
In this paper a new graph-based scheme is introduced that
also outperforms the ğ‘™1 theoretical limits and has very low
computational complexity, thanks to the use of binary sparse
matrices. The proposed scheme stems from the original design
of sudocodes [10], which has the distinctive features of taking
inï¬nite reliability decisions (i.e. no errors are made), requiring
binary sparse measurement matrices and its worst case computational complexity at the decoder side is ğ‘‚ (ğ‘˜ log(ğ‘˜) log(ğ‘›)).
The scheme in this paper combines the introduction of a
block-wise constructed binary measurement matrix structure
with the proposal of a check node degree proï¬le design
criterion and an extension of the existing veriï¬cation-based
decoding algorithms [11], [12]. This enhancement of the
veriï¬cation algorithm in [11] is particularly relevant for very
sparse signals, since in this case length-four cycles cannot be
avoided in the graph. The use of binary measurement matrices
is a key point to reduce the computational complexity at
the decoder side, as in this case the decoding process only
performs additions and comparisons, enabling the use of both
a sudocode-based or veriï¬cation-based decoder, which has
an ğ‘‚(ğ‘›) computational complexity at the decoder side. The
proposed algorithm outperforms the results in [10] and [11]
in terms of number of measurements while having a similar
decoding complexity than [11].
This paper is structured as follows. In section II we present
the proposed scheme. We introduce a systematic method
to construct binary matrices in section III. We propose in
section IV an extension of the decoding algorithm proposed
in [11] aimed at mitigating the effect of cycles of length 4
in dense binary graphs for the noiseless setting. In section V
we give a closed-form expression to obtain the appropriate
check node degree proï¬le. Finally, in section VI simulation
results illustrate the performance enhancement obtained by the
proposed compressed sensing system.

Abstractâ€”We propose a scheme for Compressed Sensing in the
noiseless setting that reconstructs the original signal operating on
a binary graph where the samples are obtained sequentially. The
proposed scheme has an affordable computational complexity
and a large performance enhancement with respect to similar
schemes in the literature, thanks to the proposed measurement
matrix structure and enhanced decoding based on a message
passing algorithm.

I. I NTRODUCTION
The Compressed Sensing (CS) problem considers the estimation of an unknown and sparse signal vector x âˆˆ ğ‘› from
ğ‘š
a vector of linear observations y âˆˆ
, ğ‘š < ğ‘›, y = Ax
ğ‘šÃ—ğ‘›
where A âˆˆ
is a ï¬xed randomly generated matrix
known as measurement matrix and only a small number ğ‘˜
(the sparsity index), ğ‘˜ << ğ‘›, of elements of x are non-zero.
The set containing the positions of these elements is known
as the support set, deï¬ned as ğ’® â‰œ {ğ‘– âˆˆ 1, ..., ğ‘› : ğ‘¥ ğ‘– âˆ•= 0},
with cardinality âˆ£ğ’®âˆ£ = ğ‘˜. The solution to this system of
Ë†
equations is known to be given by the vector x0 that minimizes
âˆ¥xâˆ¥0 (ğ‘™0 norm) subject to y = AË† 0 , which is a non-convex
x
optimization problem.
Ë†
The authors in [1], [2] established that the vector x1 with
Ë†
minimum ğ‘™1 norm subject to y = AË† 1 coincides with x0
x
whenever the measurement matrix satisï¬es the RIP condition
[1]. Some examples of RIP matrices are given, with high
probability, by matrices whose entries are i.i.d. Radamacher
or Gaussian [3] [4]. These facts enabled the development of
several ğ‘™1 -based reconstruction algorithms to solve the set
of equations (see [5], [6] and references therein) and the
characterization of the intrinsic limits, in terms of samples
(ğ‘š), of ğ‘™1 -based algorithms [7].
Recently, within this framework, the authors in [8] showed
that ğ‘š â‰¥ ğ‘˜ samples sufï¬ces to reconstruct a real-valued signal
with ğ‘˜ non-zero components in the almost lossless compression setting in the ğ‘› asymptotic regime. This result indicated
that ğ‘™1 -based algorithms are non-optimal, since they require
a number of samples larger than ğ‘˜ to succesfully recover the
signal [7]. Simultaneously, in the literature some algorithms
based on message propagation over graph representations of

4

4

4

II. S YSTEM D ESCRIPTION
We assume that the signal vector x is strictly ğ‘˜-sparse,
0 < ğ‘˜ â‰¤ ğ‘›, i.e. all the realizations have exactly ğ‘˜ non-null
components and the components that are not indexed in ğ’®
are strictly zero. The coefï¬cients indexed in ğ’® are randomly
drawn according to a generic probability density function. We

0 This work has been partially funded by the Spanish Government under the projects: TEC2007-68094-C02-02, TEC2010-21245-C02-01,
CSD2008-00010, CEN-20101019, and the Catalan Government under Grant
2009SGR1236.

1

assume through all the work that the measures y = Ax are not
corrupted by noise. A is a binary matrix where the number of
ones depends on the sparsity ratio ğ‘˜/ğ‘› and is sparse becoming
denser for very low values of ğ‘˜/ğ‘›. Matrix A is ï¬xed for all
signal realizations. It is randomly generated according to the
procedure described in section III and it is characterized by
the fraction of rows/columns with ğ‘‘ ones, denoted respectively
as R(d) and L(d), the check and variable node degree proï¬les
of the associated graph.
The proposed system employs a sequential non-adaptive
sampling procedure, i.e., the measurements are drawn one by
one following the order of the rows of matrix A and after
each new measurement is drawn a new attempt is made to
recover the sequence x. This procedure is followed until all
the components in x are identiï¬ed. Note that the number
of measurements required to reconstruct vector x may be
different for each signal realization.
The binary and sparsity features of A are exploited to
retrieve the signal vector x with a low-complexity decoding
algorithm based on the description of the system by a graph.
The decoding attempts are done using the algorithm described
in section IV-B.

The design of sub-matrices A1 ...A ğ‘ is done such that
cycles of length four are avoided whenever possible. However,
unfortunately, when the signal to be sensed is very sparse
these cycles are unavoidable if one wants to keep the number
of measurements low (and close to the theoretical limit)
and the vector length ğ‘› is ï¬nite. Indeed, if the number of
measurements is in the order of ğ‘˜ then the check node degree
must be at least ğ‘›/ğ‘˜ in order to guarantee that all signal
coefï¬cients are sensed once. Hence the check node degree
grows as the signal becomes sparse, matrix A becomes denser
and length-four cycles become unavoidable for ï¬nite length ğ‘›.
This behavior explains the relevance of the enhancement of the
decoding algorithm proposed in the next section.
IV. R ECONSTRUCTION A LGORITHM
In this section we present the proposed reconstruction
(decoding) algorithm, which is an enhancement of the veriï¬cation algorithm proposed in [11]. This algorithm performs
message passing over the bipartite graph representation of the
measurement matrix A.
The following notation is used hereafter: we denote as ğœ™
and â„ a row vector of A and the set of non-null components
of ğœ™, respectively. Hence, the cardinality of â„ is âˆ£â„âˆ£ = ğ‘‘, the
check node degree.

III. C ONSTRUCTION OF THE M EASUREMENT M ATRIX

A. Veriï¬cation Algorithm (VA)

The measurement matrix A can be represented by a graph
having three sets of nodes: signal nodes (elements of vector x),
measurement nodes (elements of vector y) and check nodes
connected to ğ‘‘ signal and one measurement nodes as indicated
by the binary measurement matrix A. Hereafter we refer to
the signal nodes as variable nodes.
The graph is fundamentally characterized by the degree
distribution of the check nodes R(ğ‘‘) and that of the variable
nodes L(ğ‘‘). We design the distribution L(ğ‘‘) to be regular, i.e.
all the variable nodes are connected to the same number/degree
ğ‘ of measurement nodes; the distribution R(ğ‘‘) is optimized in
section V, where a proï¬le R(ğ‘‘) having at most two consecutive
degrees is adopted.
Rather than generating matrix A as a random realization
of the ensemble of matrices having degrees proï¬les R(ğ‘‘)
and L(ğ‘‘), this paper proposes to introduce some structure in
the construction of matrix A. The purpose is to guarantee
that all components of vector x contribute to a measurement
before any of them is sensed again. This structure is beneï¬cial
in the sequential sampling procedure: it ensures that all the
components of vector x are sensed equally early, avoiding the
possibility that one non-zero sample may not be sensed until
late and, therefore, the sequential sampling may require a large
number of samples to stop.
Hence, we propose to construct a matrix A by sub-blocks.
Let us assume, for the sake of simplicity that all rows have the
same degree ğ‘‘. Then, ğ‘ = ğ‘šğ‘‘/ğ‘› sub-matrices A1 ...A ğ‘ of
dimension ğ‘›/ğ‘‘ Ã— ğ‘› are randomly drawn from the ensemble of
all matrices of row degree ğ‘‘ and column degree 1. Afterwards,
these sub-matrices are stacked to build matrix A as A =
[AT ...AT ]T .
1
ğ‘

First, we present the application of the veriï¬cation algorithm
(VA) in [11] to reconstruct the vector x in the set-up of
section II. This algorithm was identiï¬ed by [11] to be a
different implementation of the sudocode decoding algorithm
[10], which has ğ‘‚ (ğ‘˜ log(ğ‘˜) log(ğ‘›)) computational complexity
as opposed to [11] whose computational complexity is ğ‘‚(ğ‘›).
It must be noted that the algorithm presented in section IV-B
can be implemented as in [10] or in [11].
When applied in the CS framework, VA exploits that (i)
there is no noise, (ii) the probability density function of the
components of vector x is a continuous function with a mass
concentration at zero, ğ‘(ğ‘¥ = 0) = 1 âˆ’ ğ‘˜/ğ‘›, and (iii) the graph
has no cycles of length four. Due to these facts the following
statements hold:
âˆ™ S1. If a measurement ğ‘¦ is zero, all the variable nodes
indexed by â„ are zero.
âˆ™ S2. When the graph does not exhibit cycles of length four
and two measurements ğ‘¦ ğ‘— and ğ‘¦ ğ‘£ are identical (ğ‘¦ ğ‘— = ğ‘¦ ğ‘£ ),
that pair of measurements share a single variable node,
âˆ£â„ ğ‘— âˆ© â„ ğ‘£ âˆ£ = 1. Therefore, it follows that the common
component in the intersection set must be equal to ğ‘¦ ğ‘—
and the remaining variable nodes in â„ ğ‘— and â„ ğ‘£ must be
equal to zero.
Keeping the above statements in mind, the algorithm works
as follows. The check (variable) nodes exchange with the
variable (check) nodes messages having the following form:
{state,x} where state=â€™vâ€™ indicates that we know for sure
that the value of the associated variable node is x (i.e. the
variable node is veriï¬ed) whereas state=â€™?â€™ informs that x is
solely an estimate of the variable node value (i.e. the variable

2

Algorithm 1 Check node update rules
for
all check nodes and their measurement y
for
all the veriï¬ed messages from the variable
nodes in â„
Subtract their values from ğ‘¦ and remove
their indexes from â„ to compute ğ‘¦ â€² and â„? .
endfor
for
all variable nodes in â„? apply rules C1-C3:
C1
If ğ‘¦ â€² = 0, propagate to all the variable nodes indexed by â„? : {â€™vâ€™, 0}.
C2
If âˆ£â„? âˆ£ = 1, propagate to the variable
nodes in â„? : {â€™vâ€™, ğ‘¦ â€² }.
C3
Otherwise, propagate to all the variable nodes indexed by â„? : {â€™?â€™, ğ‘¦ â€² }.
endfor
endfor

node is still not veriï¬ed). A check node is said to verify a
neighboring variable node whenever the ï¬rst can infer with
inï¬nite reliability the value of the latter using statements S1
and S2. Then, the veriï¬ed variable node propagates its state to
the other check nodes in its neighborhood so that these check
nodes can remove the contribution of the veriï¬ed variable node
from their respective measurement and try to infer, in the next
round, the values of the remaining variable nodes connected
to them.
The iterative process starts with the variable nodes sending
a non-veriï¬ed message {â€™?â€™,âˆ’}, with dummy value âˆ’, to
all the attached check nodes. On its turn, the measurement
nodes simply send to their respective check nodes a message
containing the measurement value, {â€™vâ€™, ğ‘¦}, and do not update
their message during the decoding process.
Then, the check nodes are activated and send a message
computed as indicated by Algorithm 1, which is now explained
brieï¬‚y, to the variable nodes in their neighborhood. First of
all, each check node removes the contributions of the incoming
veriï¬ed messages from its measurement ğ‘¦ to obtain ğ‘¦ â€² . Next, it
updates all the edges connected to variable nodes that remain
not veriï¬ed (indexed in the set â„? ), according to rules C1, C2
and C3. Rule C1 exploits statement S1. Rule C2 deals with
the trivial case in which there is a single non-veriï¬ed variable
node connected to the check node. Rule C3 deals with the
remaining cases: whenever the check node cannot infer the
value of a variable node it propagates the non-veriï¬ed message
with the updated measurement, (â€™?â€™,ğ‘¦ â€² ).
After the check nodes update, the variable nodes are activated and proceed as indicated in Algorithm 2. Rule V1 deals
with veriï¬ed variable nodes. In this case, due to the absence
of noise, each veriï¬ed variable node informs to the check
nodes in its neighborhood that it is veriï¬ed by propagating
a veriï¬ed message along with its value. Rule V2 exploits
statement S2. In this case, the variable node receives more
than one non-veriï¬ed message with equal estimate ğ‘¦ â€² so it can
infer its value. Hence, the variable node switches its state to
veriï¬ed and informs of this update to all the check nodes in its
neighborhood by sending them the message {â€™vâ€™,ğ‘¦ â€² }. Finally,
in case of rule V3, the variable node just sends a non-veriï¬ed
message {â€™?â€™,âˆ’} to all the neighboring check nodes.

Algorithm 2 Variable node update rules
for
each non-veriï¬ed variable node apply rules V1-V3:
V1
If the variable node receives a veriï¬ed message, then propagate this message through
the remaining edges {â€™vâ€™, ğ‘¦ â€² }.
V2
If the variable node receives at least two
non-veriï¬ed messages with the same estimate ğ‘¦ â€² , then propagate {â€™vâ€™, ğ‘¦ â€² } to all the
nodes connected to them.
V3
Else, propagate {â€™?â€™, âˆ’} through its edges.
endfor

that variable nodes that are in the intersection must sum up
to ğ‘¦ ğ‘— . In that case, it is important that the variable nodes in
the intersection inform the check nodes of this coincidence so
that the variable nodes that do not belong to the intersection
set can be veriï¬ed as zero.
To implement the above mechanism, we have modiï¬ed the
original message passing algorithm including a new message
named coincidence. This message is generated at the variable
nodes that detect coincident measurements and is sent to the
check nodes detected to be in the coincidence state. Thanks to
this, the check nodes know that (i) there is at least another
check node with a measurement equal to its measurement
and the cardinality of the intersection (the number of received
coincident messages) and (ii) one or more of the nodes in
coincident state sum up to the measurement. In other words,
if a check node receives only a coincidence message it means
that there is no cycle of length four so it can verify the variable
node that sent the coincidence message with the value of the
measurement and the remaining nodes with zero (applying the
original rule V2). Otherwise, if the check node receives more
than one coincidence message, it sends a non-veriï¬ed message
to the variable nodes that sent coincidence messages and
propagates veriï¬cation messages {â€™vâ€™,ğ‘¥ = 0} to the remaining
ones. Brieï¬‚y, these changes are summarized as follows:
âˆ™ New variable node rule V2: If a variable node receives at
least two non-veriï¬ed messages with the same estimate,

B. Enhanced Veriï¬cation Algorithm (EVA)
This paper proposes a modiï¬cation of the veriï¬cation algorithm in section IV-A that improves its performance for very
sparse sources while preserving its ğ‘‚(ğ‘›) computational complexity and requiring only local operations. This enhancement
is similar in spirit to the one proposed in [13] for decoding of
LDPC codes in BEC channels. More speciï¬cally, the improvement consists in extending rule V2 in Algorithm 2 to deal with
graphs having cycles of length four, i.e., âˆ£â„ ğ‘— âˆ© â„ ğ‘£ âˆ£ â‰¥ 1. In the
presence of such cycles, if two measurements ğ‘¦ ğ‘— and ğ‘¦ ğ‘£ take
the same value (ğ‘¦ ğ‘— = ğ‘¦ ğ‘£ ), we know that the variable nodes
that are not in the intersection set â„ ğ‘— âˆ© â„ ğ‘£ are equal to zero
but we cannot determine the individual value of each variable
node that are in the intersection; in fact, we can only afï¬rm

3

âˆ™

n,k
10000,100
10000,10
100000,10

it sends a coincidence message to these check nodes,
and transmits {â€™?â€™,âˆ’} to the remaining nodes in its
neighborhood.
Check node rule C4: If a check node receives at least a
coincidence message, it veriï¬es as zero the variable nodes
that have not sent coincidence messages. Additionally, if
the check node receives only a coincidence message, it
veriï¬es the corresponding variable node using its own
measurement. Otherwise, it propagates {â€™?â€™,ğ‘¦ â€² } to the
variable nodes that sent coincidence messages.

R(âŒŠ Â¯ = âŒˆ Â¯ âˆ’ Â¯ R(âŒˆ Â¯ = Â¯ âˆ’ âŒŠ Â¯
ğ‘‘âŒ‹)
ğ‘‘âŒ‰ ğ‘‘,
ğ‘‘âŒ‰)
ğ‘‘
ğ‘‘âŒ‹

(5)

and Â¯ can be calculated as shown in (6)
ğ‘‘
Â¯ = âˆ’ğ‘¡1 (1 + ğ‘¡2 )/2
ğ‘‘
ğ‘
2
ğ‘¡1 =
,
+
1 âˆ’ ğ‘ log(ğ‘)

ğ‘¡2 =

âˆš

1âˆ’(4ğ‘)
log(ğ‘)(1âˆ’ğ‘)ğ‘¡2
1

(6)

Note that (6) only requires the knowledge of the sparsity ratio
of x, ğ‘ = 1 âˆ’ ğ‘˜/ğ‘›. It is worth mentioning that Â¯ is close to
ğ‘‘
the check node degrees that were found experimentally to be
optimum in [10, ï¬gure 2] and that Â¯ increases as ğ‘›/ğ‘˜ increases.
ğ‘‘
The idea behind equation (4) is that by verifying as much
variable nodes per measurement as possible the phase transition2 zone will be reached as soon as possible (in terms
of samples). The EVA algorithm shows a kind of avalanche
effect when it reaches its phase transition zone: once it reaches
this zone the addition of a single sample may enable the
veriï¬cation of a large fraction of variable nodes. This happens
because rule C2 in Algorithm 1 is activated when the average
number of non-veriï¬ed variable nodes connected to check
nodes is close to 1. When this happens the avalanche effect
is triggered; before that, variable nodes can only be veriï¬ed
in the graph when statements S1 and S2 in section IV-A or
modiï¬ed S2 in section IV-B happen. Hence, by maximizing
the fraction of variable nodes connected to check nodes with
âˆ£â„ âˆ© ğ’®âˆ£ â‰¤ 1 we try to reduce as fast as possible the number
of non-veriï¬ed variable nodes while keeping low the number
of generated measurements.

(2)

However, we also generate measurements with contribution
of more than one non-null component of vector x such that
âˆ£â„ âˆ© ğ’®âˆ£ > 1, with a probability
ğ‘(âˆ£â„ âˆ© ğ’®âˆ£ > 1) = 1 âˆ’ ğ‘(âˆ£â„ âˆ© ğ’®âˆ£ = 1) âˆ’ ğ‘(âˆ£â„ âˆ© ğ’®âˆ£ = 0). (3)
According to equations (1)-(3), the probability of verifying
null and non-null components of x depends critically on ğ‘‘
and ğ‘. Hence, the veriï¬cation process can be sped up by
selecting a degree R(ğ‘‘) that balances properly the amount
of vectors generated according to equations (1) and (2).
With this purpose, we propose to employ the check node
degree distribution R(ğ‘‘) that maximizes the average number
of variable nodes connected to check nodes so as âˆ£â„ âˆ© ğ’®âˆ£ â‰¤ 1,
as follows
âˆ‘
maximize
R(ğ‘‘) ğ‘‘ ğ‘(âˆ£â„ âˆ© ğ’®âˆ£ â‰¤ 1)

VI. RESULTS
Table I compares the joint performance of the proposed
matrix construction method, the proposed check node degree
design and the proposed message passing algorithm with the
performance of the sudocodes [10]. In this table, ğ‘š represents

âˆ€ğ‘‘

R(ğ‘‘) â‰¥ 0,
âˆ‘
R(ğ‘‘) = 1

EVA.

4

and tells us the probability of recovering ğ‘‘ zeros of vector
x from a single measurement. Obtaining a vector ğœ™ which
overlaps only with one element of the support set of x, i.e.
âˆ£â„ âˆ© ğ’®âˆ£ = 1, happens with probability

subject to

OF SUDOCODES WITH

âˆ£â„âˆ©ğ’®âˆ£ â‰¤ 1 for asymptotic ğ‘š. Then it follows that ğ‘‘ ğ‘(âˆ£â„âˆ©ğ’®âˆ£ â‰¤
1) is the average number of edges per check node that satisfy
âˆ£â„ âˆ© ğ’®âˆ£ â‰¤ 1 for a given ğ‘ and ğ‘‘.
It is straightforward to show that for a ï¬xed ğ‘ and ğ‘‘ âˆˆ +
the relaxed function ğ‘‘ ğ‘(âˆ£â„ âˆ©ğ’®âˆ£ â‰¤ 1) has a single maximum at
Â¯ It can be shown that whenever we ï¬x the number of non-null
ğ‘‘.
coefï¬cients of R(ğ‘‘) to two and assuming that ğ‘›/ğ‘˜ >> 1, the
optimum choice of the two non-null degrees are the closest
âˆ‘
ones around Â¯ In this case
ğ‘‘.
R(ğ‘‘)ğ‘‘ ğ‘(âˆ£â„ âˆ© ğ’®âˆ£ â‰¤ 1) has a
unique solution R(ğ‘‘) that can be inferred from Â¯ as follows1
ğ‘‘

V. D ESIGN OF THE C HECK N ODE D EGREE

R(ğ‘‘)

Proposed method
m=375
m=85
m=92

Table I
C OMPARISON

This section analyzes the inï¬‚uence of the sparsity ratio
on the performance of a VA-based decoding scheme and
applies the results to obtain a criterion to design R(ğ‘‘) for
the veriï¬cation algorithm. Even though it is out of the scope
of the current work, it must be noted that the performance of
the EVA can be further improved in graphs with length-four
cycles by changing the criteria to design of the R(ğ‘‘).
Let us consider the case ğ‘› â†’ âˆ and call ğ‘ the nonvanishing probability of a signal component being 0, ğ‘ =
1 âˆ’ ğ‘˜/ğ‘›. For simplicity we assume that all the ğœ™ vectors
have degree ğ‘‘. Then, when all the ones in ğœ™ overlap with null
components of x, âˆ£â„ âˆ© ğ’®âˆ£ = 0, the measurement ğ‘¦ = ğœ™ ğ‘‡ x
is equal to zero, using statement S1. This happens with
probability:
ğ‘(âˆ£â„ âˆ© ğ’®âˆ£ = 0) = ğ‘ ğ‘‘
(1)

ğ‘(âˆ£â„ âˆ© ğ’®âˆ£ = 1) = ğ‘‘ ğ‘ ğ‘‘âˆ’1 (1 âˆ’ ğ‘).

Sudocodes [10]
m=803
m=461
m=931

(4)
1 Derivation

is omitted due to space constraints
Compressed Sensing, the reconstruction algorithms show a dual behavior, i.e. algorithms do not converge to a solution until the number of samples
ğ‘š is large enough. The limit between the zone were algorithms converge and
do not converge is known as the phase transition zone. See [7], [8] for further
details.
2 In

âˆ€ğ‘‘

where ğ‘(âˆ£â„ âˆ© ğ’®âˆ£ â‰¤ 1) = ğ‘(âˆ£â„ âˆ© ğ’®âˆ£ = 0) + ğ‘(âˆ£â„ âˆ© ğ’®âˆ£ = 1).
Note that ğ‘(âˆ£â„ âˆ© ğ’®âˆ£ â‰¤ 1) is the fraction of check nodes with

4

1

employing measurement matrices constructed with the method
proposed in this paper. Notice that, the latter range coincides
with ğ‘›/ğ‘˜ â‰¥ 100 for ğ‘› = 16000.

VA. pe=0.5
âˆ’3

0.8

VA. pe=10

EVA. p =0.5

VII. C ONCLUSIONS

e

âˆ’3

EVA. p =10

This paper has proposed a graph-based CS scheme that
outperforms sudocodes irrespective of the sparsity ratio and
also outperforms VA in very sparse scenarios when the
measurement matrix is binary. The performance enhancement
for sparsity ratios where a length-4 cycle-free graph can
be constructed is obtained employing the proposed matrix
structure and check node degree distribution, specially aimed
to exploit the features of the VA algorithm. For larger sparsity
ratios, an enhanced decoding algorithm has been introduced
that allows to deal with cycles of length-4. The combination
of the proposed enhancements over existing methods in the
literature allow to obtain a low complexity CS scheme with
good performance that outperforms the ğ‘™1 theoretical limits in
the noiseless setting.
Further work must be done to improve the performance of
this scheme in the noiseless setting, ï¬rst by ï¬nding new rules
to enhance the performance of the reconstruction algorithm
and ï¬nding new methods to design binary matrices to exploit
both the enhancement of the EVA and these new rules.

e

LPâˆ’PT

k/m

0.6
0.4
0.2
0
0

0.2

0.4

m/n

0.6

0.8

1

Figure 1. Phase transition diagram as a function of sampling, sparsity and
block length ğ‘›. Comparison of veriï¬cation (VA) and enhanced veriï¬cation
(EVA) algorithm for n=16000 and several sparsity ratios on a phase diagram.

the maximum number of samples required for perfect reconstruction obtained after 105 Monte Carlo simulations. Note
that the number of samples required by the proposed scheme
is 2 to 10 times smaller that the one required by sudocodes. It
must be noted that the proposed method also outperforms that
one in [11, ï¬gure 6] where the adopted LM2-MB algorithm
is the VA algorithm in presented in section IV-A. In this
case for ğ‘› = 10000 the method in [11] requires ğ‘š > 500
measurements to reconstruct a sequence with ğ‘˜ = 100; in our
case, ğ‘š = 375 sufï¬ces to reconstruct almost any sequence
with ğ‘˜ = 100 (see table I).
Figure 1 shows a phase transition diagram as a function
of the number of samples ğ‘š, sparsity ğ‘˜ and block length ğ‘›.
The horizontal axis corresponds to the sampling ratio, ğ›¿ =
ğ‘š/ğ‘›. The vertical axis represents the ratio ğœŒ = ğ‘˜/ğ‘š. The
curve labeled as LP-PT is phase transition for ğ‘™1 reconstruction
[7]. The curves represent the performance of the veriï¬cation
(VA) and enhanced veriï¬cation (EVA) algorithms for different
Ë†
ğ‘ ğ‘’ = ğ‘(x âˆ•= x) when the proposed matrix construction is
employed. The same measurement matrix was employed to
run all the simulations (VA and EVA) for a ï¬xed ğ‘›/ğ‘˜ ratio.
The plots depict the performance of the veriï¬cation algorithm
with binary matrices (VA). These matrices were obtained with
the structure presented in section III and with R(ğ‘‘) selected
for ğ‘ = 1 âˆ’ ğ‘˜/ğ‘› as indicated by equations (6) and (5). At least
105 Monte Carlo simulations were run per point.
The plots obtained with VA and EVA show a dual behavior:
both have the same performance as long as it is possible to
generate graphs without cycles of length 4 (for ğ›¿ < 0.05
in this case, i.e. ğ‘›/ğ‘˜ > 100). Once the measurement matrix
becomes dense, i.e. for large ğ‘›/ğ‘˜ ratios, the behavior of the
algorithms changes: VA performance decreases dramatically
whereas EVA performance falls slowly. These results can be
compared with the ğ‘™1 theoretical limit for asymptotic ğ‘›. Figure
1 shows that VA can outperform the ğ‘™1 in an approximate range
between ğ›¿ âˆˆ (0.05, 0.25) and EVA between ğ›¿ âˆˆ (0, 0.25), both

R EFERENCES
[1] D.L. Donoho, â€œCompressed sensing,â€ IEEE Trans. Inform. Theory, vol.
52, no. 4, pp. 1289 â€“1306, April 2006.
[2] E.J. Candes and T. Tao, â€œNear-optimal signal recovery from random
projections: Universal encoding strategies?,â€ IEEE Trans. Inform.
Theory, vol. 52, no. 12, pp. 5406 â€“5425, December 2006.
[3] R. Baraniuk, M. Davenport, R. DeVore, and M. Wakin, â€œA simple proof
of the restricted isometry property for random matrices,â€ Constructive
Approximation, vol. 28, pp. 253â€“263, 2008.
[4] Venkat Chandar, â€œA negative result concerning explicit matrices with
the restricted isometry property,â€ Tech. Rep., 2008.
[5] T. Blumensath and M.E. Davies, â€œStagewise weak gradient pursuits,â€
IEEE Trans. Signal Process., vol. 57, no. 11, pp. 4333 â€“4346, November
2009.
[6] R. Calderbank, S. Howard, and S. Jafarpour, â€œConstruction of a large
class of deterministic sensing matrices that satisfy a statistical isometry
property,â€ IEEE J. of Sel. Topics in Signal Process., vol. 4, no. 2, pp.
358 â€“ 374, April 2010.
[7] David L. Donoho, Arian Maleki, and Andrea Montanari, â€œMessagepassing algorithms for compressed sensing,â€ Proceedings of the National
Academy of Sciences, vol. 106, no. 45, pp. 18914â€“18919, 2009.
[8] W. Yihong and S. Verdu, â€œRenyi information dimension: Fundamental
limits of almost lossless analog compression,â€ IEEE Trans. Inform.
Theory, vol. 56, no. 8, pp. 3721 â€“3748, August 2010.
[9] P. Schniter, â€œTurbo reconstruction of structured sparse signals,â€ in
Information Sciences and Systems (CISS), 2010 44th Annual Conference
on, March 2010, pp. 1 â€“6.
[10] S. Sarvotham, D. Baron, and R.G. Baraniuk, â€œSudocodes - fast
measurement and reconstruction of sparse signals,â€ in 2006 IEEE
International Symposium on Information Theory, July 2006, pp. 2804
â€“2808.
[11] Fan Zhang and H. D. Pï¬ster, â€œOn the iterative decoding of high-rate
LDPC codes with applications in compressed sensing,â€ CoRR, vol.
abs/0903.2232, 2009.
[12] Fan Zhang and H.D. Pï¬ster, â€œAnalysis of veriï¬cation-based decoding
on the q -ary symmetric channel for large q,â€ Information Theory, IEEE
Transactions on, vol. 57, no. 10, pp. 6754 â€“6770, Octuber 2011.
[13] P.M. Olmos, J.J. Murillo-Fuentes, and F. Perez-Cruz, â€œTree-structure
expectation propagation for decoding LDPC codes over binary erasure
channels,â€ in Information Theory Proceedings (ISIT), 2010 IEEE
International Symposium on, June 2010, pp. 799 â€“803.

5

