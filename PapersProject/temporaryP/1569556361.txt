Title:          untitled
Creator:        'Certified by IEEE PDFeXpress at 05/17/2012 10:26:24 AM'
Producer:       Appligent StampPDF Batch, version 5.1
CreationDate:   Thu May 17 10:26:18 2012
ModDate:        Tue Jun 19 12:56:41 2012
Tagged:         no
Pages:          4
Encrypted:      no
Page size:      612 x 792 pts (letter)
File size:      268885 bytes
Optimized:      no
PDF version:    1.7
ISIT'2012 1569556361

Greedy Codes over â„¤4
Kenza Guenda

T. Aaron Gulliver and S. Arash Sheikholeslam

Faculty of Mathematics USTHB
University of Sciences and Technology of Algiers
B.P. 32 El Alia, Bab Ezzouar, Algiers, Algeria
Email: kguenda@gmail.com

Dept. of Electrical and Computer Engineering
University of Victoria
P.O. Box 3055, STN CSC, Victoria, BC Canada V8W 3P6
Email: agullive@ece.uvic.ca

the resulting lexicode ğ¶(ğµ, ğ‘ƒ ) is linear and each vector
x âˆˆ ğ¶(ğµ, ğ‘ƒ ) satisï¬es the property ğ‘ƒ .
In this paper, we consider the construction of lexicodes
using a ğµ-ordering over the ring â„¤4 and a selection property
ğ‘ƒ . We deï¬ne multiplicative properties over â„¤4 and give a
greedy algorithm over â„¤4 . Since the code obtained depends
on the ğµ ordering and the property ğ‘ƒ , we denote it by
ğ¶(ğµ, ğ‘ƒ ). Note that this greedy algorithm can be used with
any multiplicative property as deï¬ned in this paper. We prove
that the code ğ¶(ğµ, ğ‘ƒ ) when using a selection property on
the weight has covering radius equal to ğ‘‘ âˆ’ 1. Hence via the
Gray map ğ’¢, we prove that the corresponding binary codes
ğ’¢(ğ¶(ğµ, ğ›¿)) meet the Gilbert bound. We compare the lexicodes
obtained using our algorithm with the optimal codes in [8].
This shows that many of the codes are optimal over â„¤4 , and
several optimal binary codes are also obtained.
Recall that a selection property ğ‘ƒ on ğ‘‰ can be considered
as a boolean valued function ğ‘ƒ : ğ‘‰ âˆ’â†’ {True, False} that
depends on one variable. We call ğ‘ƒ a multiplicative property
if ğ‘ƒ [x] is true implies ğ‘ƒ [3x] is true for all x âˆˆ ğ‘‰ . This is
slightly different from the deï¬nition given by van Zanten and
Nengah Suparta [13]. Our choice is justiï¬ed by the arguments
given in Remark 1.
The remainder of the paper is organized as follows. In
Section II we present the main algorithm, and prove that
the codes obtained are linear and the selection criteria ğ‘ƒ is
satisï¬ed for all codewords. In Section III we consider selforthogonal codes. We prove that the multiplicative condition
ğ‘¥ â‹… ğ‘¥ = 0 which results in self-orthogonal codes over ï¬nite
ï¬elds is not sufï¬cient for rings, although self-orthogonal codes
may be obtained. In Section IV, lexicodes are given based on
the Lee-weight criteria. In Section V we prove that the binary
codes obtained as the Gray map of codes constructed using
the Lee weight selection property meet the Gilbert bound.

Abstractâ€”In this paper, we consider the construction of lexicodes by using a ğµ-ordering over the ring â„¤4 . This algorithm can
be applied to any multiplicative property over â„¤4 . It is shown
that this construction produces many optimal codes over â„¤4 and
also good binary codes.

I. I NTRODUCTION
Surprisingly, many good binary linear codes can be constructed using the following greedy algorithm with minimum
distance as the selection criterion. Starting with the all zero
vector, all binary vectors of length ğ‘› are considered in lexicographic order, and when the distance of a vector to all other
vectors in the code is at least ğ›¿, the vector is added to the
code. Levenstein [11] proved that the resulting code (called
lexicode), is linear. Conway and Sloane [6] proved that the
ğ‘™
lexicodes are linear over ï¬elds of order 22 , ğ‘™ âˆˆ â„•. Moreover,
they proved linearity when using a more general selection
criterion called a turning-set. Brualdi and Pless [5] discussed
another generalization of binary lexicodes. They introduced
the concept of ğµ-ordering, which is used in the greedy
algorithm instead of the standard basis. Their starting point is
a list of binary vectors of length ğ‘›, ordered lexicographically
with respect to a basis obtained by adding recursively all
previous words to the next basis word. They also proved that
the resulting lexicodes are linear. Unfortunately, for ï¬elds other
than ğ”½2 , the lexicodes constructed using a ğµ-ordering are not
always linear. To solve this problem, Bonn [3] introduced
another concept called forcing linearity. In this case, a list of
all vectors over ğ”½ ğ‘ of length ğ‘› is searched. This list need not be
ordered in a speciï¬c way. If a vector a satisfying ğ‘‘(a, y) â‰¥ ğ›¿
is found, then a is added to the lexicode as well as all its
multiples without checking the minimum distance condition.
Surprisingly, the minimum distance condition is satisï¬ed for
all added words [3, Proposition 1]. Thus the resulting code,
which is forced to be linear over all ï¬nite ï¬elds, has a basis
composed of the selected vectors a and has minimum distance
greater than or equal to the designed distance ğ›¿. Azab et al. [1]
presented an almost greedy algorithm over â„¤4 using a ğµordering and considering the Lee distance.
Recently, van Zanten and Nengah Suparta [13] generalized
the work of Bonn to a more general selection property over
an arbitrary ï¬nite ï¬eld ğ”½ ğ‘ . They considered a ğµ-ordering on
ğ”½ ğ‘ğ‘› . The basis ğµ = {b1 , . . . , b ğ‘› } is ordered with respect
to a lexicographically ordered list in a recursive way. By
using a multiplicative selection property ğ‘ƒ , they proved that

II. C ONSTRUCTION OF L EXICODES OVER â„¤4
A linear code ğ¶ of length ğ‘› over â„¤4 is an additive subgroup
over â„¤4ğ‘› . For x âˆˆ â„¤4ğ‘› , denote the number of components of
x equal to ğ‘ by ğ‘› ğ‘ (x). Hence the Hamming weight of x is
ğ‘¤ğ‘¡ ğ» (x) = ğ‘›1 (x) + ğ‘›2 (x) + ğ‘›3 (x). The Lee weight of x is
ğ‘¤ğ‘¡ ğ¿ (x) = ğ‘›1 (x) + 2ğ‘›2 (x) + ğ‘›3 (x), and the Euclidean weight
of x is ğ‘¤ğ‘¡ ğ¸ (x) = ğ‘›1 (x) + 4ğ‘›2 (x) + ğ‘›3 (x). The Hamming, Lee
and Euclidean distances ğ‘‘ ğ» (x, y), ğ‘‘ ğ¿ (x, y), ğ‘‘ ğ¸ (x, y) between
two vectors x and y are ğ‘¤ğ‘¡ ğ» (x âˆ’ y), ğ‘¤ğ‘¡ ğ¿ (x âˆ’ y) and ğ‘¤ğ‘¡ ğ¸ (x âˆ’

1

y), respectively. The minimum Hamming, Lee and Euclidean
weights, ğ‘‘ ğ» , ğ‘‘ ğ¿ and ğ‘‘ ğ¸ of ğ¶ are the smallest Hamming, Lee
and Euclidean weights among all nonzero codewords of ğ¶.
â„¤4ğ‘› is a linear code over â„¤4 with basis ğµ = {ğ‘1 , . . . , ğ‘ ğ‘› }.
With respect to this basis, we recursively deï¬ne a lexicographically ordered list ğ‘‰ ğ‘– = ğ‘¥1 , ğ‘¥2 , . . . , ğ‘¥4 ğ‘– as follows

ğ´ we have a nested sequence of linear codes
0 = ğ¶0 âŠ‚ ğ¶1 âŠ‚ . . . âŠ‚ ğ¶ ğ‘› .

The set ğµ = {ğ‘ ğ‘–1 , . . . , ğ‘ ğ‘–ğ‘™ } is a generating set for the code
ğ¶ ğ‘– . The code ğ¶ ğ‘› is the so-called lexicode. This is a maximal
code in the sense that it cannot be contained in a larger code
with the same generating set and property. Since the codes ğ¶ ğ‘–
ğ‘‰0 := 0,
depend only on the selection property ğ‘ƒ and ordering ğµ, the
ğ‘‰ ğ‘– := ğ‘‰ ğ‘–âˆ’1 , ğ‘ ğ‘– + ğ‘‰ ğ‘–âˆ’1 , 2ğ‘ ğ‘– + ğ‘‰ ğ‘–âˆ’1 , 3ğ‘ ğ‘– + ğ‘‰ ğ‘–âˆ’1 , 1 â‰¤ ğ‘– â‰¤ ğ‘›.
code ğ¶ ğ‘› is denoted by ğ¶(ğµ, ğ‘ƒ ).
In this way âˆ£ğ‘‰ ğ‘– âˆ£ = 4 ğ‘– , and we can identify â„¤4ğ‘› by ğ‘‰ ğ‘› . Assume
Remark 1: Our deï¬nition of the multiplicative property
now that we have a property ğ‘ƒ which can test if a vector differs from that of van Zanten and Nengah Suparta [13].
c âˆˆ â„¤4ğ‘› is selected or not. If this property is multiplicative, the They deï¬ned a multiplicative property over a ï¬nite ï¬eld as a
following greedy algorithm provides lexicodes over â„¤4ğ‘› .
boolean valued function ğ‘ƒ for which ğ‘ƒ [x] implies ğ‘ƒ [ğ›¼x] for
Algorithm A
all ğ›¼ âˆˆ ğ”½ ğ‘ . Since ğ‘ƒ [a ğ‘– + c] holds, then ğ‘ƒ [a ğ‘– + ğ›¼c] from Step
2 of [13, Algorithm A]. If the property ğ‘ƒ is multiplicative,
1) ğ¶0 := 0; ğ‘– := 1;
then ğ‘ƒ [ğ›¼âˆ’1 (a ğ‘– + ğ›¼c)] = ğ‘ƒ [ğ›¼âˆ’1 a ğ‘– + c] for all ğ›¼ âˆˆ ğ¹ ğ‘ . This is
2) select the ï¬rst vector ai âˆˆ ğ‘‰ ğ‘– âˆ– ğ‘‰ ğ‘–âˆ’1 such that ğ‘ƒ [ai + c] and
no longer true over rings since there are zero divisors. Hence
ğ‘ƒ [2ai + c] for all c âˆˆ ğ¶ ğ‘–âˆ’1 ;
3) if such an ğ‘ ğ‘– exists, then ğ¶ ğ‘– := ğ¶ ğ‘–âˆ’1 , ğ‘ ğ‘– + ğ¶ ğ‘–âˆ’1 , 2ğ‘ ğ‘– + there are some vectors c âˆˆ ğ¶ ğ‘– which are missing and may
not satisfy the property ğ‘ƒ even if the code is linear and the
ğ¶ ğ‘–âˆ’1 , 3ğ‘ ğ‘– + ğ¶ ğ‘–âˆ’1 ; otherwise ğ¶ ğ‘– := ğ¶ ğ‘–âˆ’1 ;
property is multiplicative. This justiï¬es our modiï¬cation of
4) ğ‘– := ğ‘– + 1; return to 2.
the multiplicative property and adding the constraint in Step
For 0 < ğ‘– â‰¤ ğ‘›, the codes ğ¶ ğ‘– are forced to be linear because we
2 to also satisfy ğ‘ƒ [2a ğ‘– + c].
take all linear combinations of the selected vectors ğ‘ ğ‘–1 , . . . , ğ‘ ğ‘–ğ‘™ ;
Theorem 2: For any basis ğµ of â„¤4ğ‘› and any multiplicative
ğ‘™ â‰¤ ğ‘–. ğ¶ ğ‘– has a generating set formed by the selected vectors
selection criteria ğ‘ƒ , the lexicode ğ¶(ğµ, ğ‘ƒ ) is linear and ğ‘ƒ [x]
ğ‘ ğ‘–1 , . . . , ğ‘ ğ‘–ğ‘™ .
holds for each codeword x âˆ•= 0.
Considering the greedy algorithm [13, Algorithm A] for
Proof: The linearity of the code is assured by the code
ï¬nite ï¬elds, a natural question that arises is, can a vector construction. Since ğ‘ƒ [a + c], ğ‘ƒ [2a + c] for all c âˆˆ ğ¶ , and
i
i
ğ‘–âˆ’1
/
x âˆˆ ğ‘‰ ğ‘– âˆ– ğ‘‰ ğ‘–âˆ’1 exist with ğ‘ƒ [x + c] for all c âˆˆ ğ¶ ğ‘– and x âˆˆ ğ¶ ğ‘– . the property ğ‘ƒ is multiplicative, then for all c âˆˆ ğ¶ , we also
ğ‘–âˆ’1
The following lemma, which is an extension of [13, Theorem have ğ‘ƒ [3a + 3c], and ğ‘ƒ [2a + 3c]. Since ğ¶
i
i
ğ‘–âˆ’1 is linear, this is
2.1], guarantees that such a vector x does not exist.
equivalent to having that ğ‘ƒ [ğ›¼ai +c] for all c âˆˆ ğ¶ ğ‘–âˆ’1 . Applying
Lemma 1: Let ğ‘ƒ be a multiplicative property over â„¤4 , and this result for ğ‘– = 1, 2, . . . , ğ‘˜ sequentially yields that ğ‘ƒ [x] is
let ai âˆˆ ğ‘‰ ğ‘– be such that ğ‘ƒ [ai +c] and ğ‘ƒ [2ai +c] for all c âˆˆ ğ¶ ğ‘–âˆ’1 , true for any codeword x âˆ•= 0, since the vectors a , a , . . . , a
1 2
k
for ğ‘– â‰¥ 1. Then every x âˆˆ ğ‘‰ ğ‘– âˆ– ğ‘‰ ğ‘–âˆ’1 satisfying ğ‘ƒ [x + c] and constitute a generating set for the code ğ¶(ğµ, ğ‘ƒ ).
ğ‘ƒ [2x + c] for all c âˆˆ ğ¶ ğ‘– is in ğ¶ ğ‘– .
III. S ELF -O RTHOGONAL C ODES
Proof: The proof is by induction on ğ‘–. Let ğ‘— > 0 be the
ï¬rst index such that ğ‘ƒ [aj ] and ğ‘ƒ [2aj ]. Hence ğ¶0 = ğ¶1 =
Let x = ğ‘¥1 . . . ğ‘¥ ğ‘› and y = ğ‘¦1 . . . ğ‘¦ ğ‘› be two elements of
. . . = ğ¶ ğ‘—âˆ’1 = 0, ğ¶ ğ‘— = 0, aj , 2aj , 3aj . Let x âˆˆ ğ‘‰ ğ‘— âˆ– ğ‘‰ ğ‘—âˆ’1 be a â„¤4ğ‘› . The inner product of x and y in â„¤4ğ‘› is deï¬ned as x â‹… y =
vector such that ğ‘ƒ [x + ğ›¼a ğ‘— ] and ğ‘ƒ [2x + ğ›¼a ğ‘— ] for 0 â‰¤ ğ›¼ â‰¤ 3. ğ‘¥1 ğ‘¦1 + . . . + ğ‘¥ ğ‘› ğ‘¦ ğ‘› (mod 4). Let ğ¶ be a â„¤4 linear code of
Since x âˆˆ ğ‘‰ ğ‘— âˆ– ğ‘‰ ğ‘—âˆ’1 , we can write x = ğ›½aj + v for some length ğ‘›. The dual code of ğ¶ is deï¬ned as ğ¶ âŠ¥ = {ğ‘¥ âˆˆ â„¤4 âˆ£ğ‘¥ â‹…
ğ›½ âˆ•= 0 and some v âˆˆ ğ‘‰ ğ‘–âˆ’1 . If v = 0, then we have x = ğ›½a ğ‘— . ğ‘ = 0 for all ğ‘ âˆˆ ğ¶}. A code is said to be self-orthogonal if
Hence x âˆˆ ğ¶ ğ‘— . If v âˆ•= 0, we ï¬rst take ğ›¼ = âˆ’ğ›½ and obtain
ğ¶ âŠ‚ ğ¶ âŠ¥.
ğ‘ƒ [v], then take ğ›¼ = âˆ’2ğ›½ and obtain ğ‘ƒ [2v]. This contradict
Using Algorithm A and the selection property ğ‘ƒ [x] is true if
the assumption on ğ‘—.
and only if x â‹… x = 0, we obtain linear lexicodes ğ¶(ğµ, ğ‘ƒ ) over
Let ai âˆˆ ğ‘‰ ğ‘– , ğ‘– > ğ‘—, be a selected vector such that ğ‘ƒ [ai + c] â„¤4ğ‘› . This is because this property is multiplicative over â„¤4 , i.e.,
and ğ‘ƒ [2ai + c] for all c âˆˆ ğ¶ ğ‘–âˆ’1 . Assume that the lemma holds x â‹… x = 0 implies that 3x â‹… 3x = 0. Hence from Theorem 2, we
for all relevant index values less that ğ‘–. Now let x âˆˆ ğ‘‰ ğ‘– âˆ– ğ‘‰ ğ‘–âˆ’1 have that the code ğ¶(ğµ, ğ‘ƒ ) for this criteria is linear and ğ‘ƒ [x]
such that ğ‘ƒ [x + c] and ğ‘ƒ [2x + c] for all c âˆˆ ğ¶ ğ‘– . Since x âˆˆ holds for all x âˆˆ ğ¶(ğµ, ğ‘ƒ ). Table I presents a number of codes
ğ‘‰ ğ‘– âˆ– ğ‘‰ ğ‘–âˆ’1 , we can write x = ğ›½a ğ‘– + v for some v âˆˆ ğ‘‰ ğ‘–âˆ’1 obtained using this selection property. In the case of lexicodes
and ğ›½ âˆ•= 0. If we take c = âˆ’ğ›½a ğ‘– + câ€² and c = âˆ’2ğ›½ai + câ€² , over ï¬elds, this selection criteria is sufï¬cient to produce selfit follows that ğ‘ƒ [v + câ€² ] and ğ‘ƒ [2v + câ€² ] for all câ€² âˆˆ ğ¶ ğ‘–âˆ’1 . orthogonal lexicodes. However this is not the case over â„¤4 ,
From the induction assumption we have that v âˆˆ ğ¶ ğ‘–âˆ’1 . Since since the argument of [13, Corollary 5.1] is not true over rings,
x = ğ›½ai + v, hence x âˆˆ ğ¶ ğ‘– .
namely we can have xâ‹…x = 0, y â‹…y = 0 and (x+y)â‹…(x+y) = 0
Lemma 1 shows that when a vector ai âˆˆ ğ‘‰ ğ‘– is found without having x â‹… y = 0. However, this criteria may result in
satisfying Step 2 of Algorithm A, and after extending the list of a self-orthogonal code. For instance, the ï¬rst code in Table I
codewords in Step 3, we can continue the selection procedure is self-orthogonal, whereas the others are not. In this table,
by searching the sublist ğ‘‰ ğ‘–+1 âˆ–ğ‘‰ ğ‘– . Thus at the end of Algorithm
ğº ğ¶(ğµ,ğ‘ƒ ) is the generator set for the code ğ¶(ğµ, ğ‘ƒ ).

2

TABLE I
L EXICODES OVER â„¤4ğ‘› WITH THE S ELECTION P ROPERTY x â‹… x = 0
ğ‘›
3

Basis of â„¤4ğ‘›
Canonical basis

4

b1 = 0001
b2 = 1100
b3 = 0110
b4 = 0011
Canonical basis

6

6

8

8

b1 = 322323
b2 = 220033
b3 = 311201
b4 = 322122
b5 = 212130
b6 = 231230
Canonical basis

b1
b2
b3
b4
b5
b6
b7
b8

=
=
=
=
=
=
=
=

32121211
01132301
23002111
22231202
11200323
01312220
20121213
31012112

ğº ğ¶(ğµ,ğ‘ƒ )
a1 = 200
a2 = 002
a1 = 0002
a2 = 1100
a3 = 0110
a4 = 0011
a1 = 200000
a2 = 101000
a3 = 110000
a4 = 100100
a5 = 100010
a6 = 100001
a1 = 200202
a2 = 220033
a3 = 311201
a4 = 322122
a5 = 130013
a6 = 113113
a1 = 200000000
a2 = 11000000
a3 = 10100000
a4 = 10010000
a5 = 10001000
a6 = 10000100
a7 = 10000010
a8 = 10000001
a1 = 20202022
a2 = 33213112
a3 = 23002111
a4 = 22231202
a5 = 11200323
a6 = 33033031
a7 = 20121213
a8 = 23133323

TABLE II
L EXICODES OVER â„¤4ğ‘› WITH THE S ELECTION P ROPERTY ğ‘¤ ğ¿ (x) â‰¥ ğ›¿

Type
22

ğ‘‘ğ¿
2

ğ‘›
3

Basis of â„¤4ğ‘›
Canonical basis

ğ›¿
2

43 2

2

4

2

45 2

2

5

b1 = 0001
b2 = 1100
b3 = 0110
b4 = 0011
Canonical basis
b1 = 10100
b2 = 10010
b3 = 33100
b4 = 00003
b5 = 00100
Canonical basis

3

b1
b2
b3
b4
b5
b6

2

5
45 2

2
6

47 2

6
2

=
=
=
=
=
=

231311
122322
122101
211321
110321
132023

6

3

4

3
â€

47 2

2

6

4
â€

6

â€

5

6

â€

6

ğº ğ¶(ğµ,ğ‘ƒ )
a1 = 110
a2 = 101
a1 = 1100
a2 = 0110
a3 = 0011

Type
42 2

ğ‘‘ğ¿
2

SO/O
Ã—

43 2

2

Ã—

11100
21010
31001
11110
33103

43

3

Ã—

42

3

Ã—

a1 = 211000
a2 = 12011
a3 = 200011
a1 = 231311
a2 = 122322
a2 = 122101
a2 = 312221

43

4

S

44

2

Ã—

a1
a2
a3
a1
a2
a3
a1
a2
a1

43

4

S

43

4

S

42

5

SO

4

7

SO

a1
a2
a3
a1
a2

=
=
=
=
=

=
=
=
=
=
=
=
=
=

231311
122101
333203
231311
122101
210001
231311
122101
231311

from â„¤4 to ğ”½2 is deï¬ned as
2

IV. L EXICODES WITH A W EIGHT C RITERIA

ğ’¢ â€² (0) = 00, ğ’¢ â€² (1) = 01, ğ’¢ â€² (2) = 11, ğ’¢ â€² (3) = 10.

As mentioned in the Introduction, the ï¬rst lexicodes were
obtained using a weight criteria over ï¬nite ï¬elds. The weight
criteria with the Lee weight is not multiplicative in â„¤4 in the
sense of [13]. Conversely, with the modiï¬ed deï¬nition of the
multiplicative property we have the following result.
Lemma 3: Let ğ›¿ be a positive integer. We have the property
ğ‘ƒ [x] if and only if ğ‘¤ ğ¿ (x) â‰¥ ğ›¿ is a multiplicative property.
Proof: We must show that if ğ‘¤ ğ¿ (x) â‰¥ ğ›¿ then ğ‘¤ ğ¿ (3x) â‰¥ ğ›¿.
It is easy to see that ğ‘›1 (3x) = ğ‘›3 (x), ğ‘›3 (3x) = ğ‘›1 (x) and
ğ‘›2 (3x) = ğ‘›2 (x). This gives that ğ‘¤ ğ¿ (3x) = ğ‘¤ ğ¿ (x). Hence the
result follows.
Corollary 4: The lexicode ğ¶(ğµ, ğ›¿) given by Algorithm A
for designed distance ğ›¿ is a linear code over â„¤4 with minimum
distance greater than or equal to ğ›¿.
Tables II and III presents some lexicodes obtained using the
weight criteria. The notation Ã— denotes that the code is not
self-dual, ğ‘† denotes that the code is self-dual, and ğ‘†ğ‘‚ denotes
that the code is self-orthogonal. ğº ğ¶(ğµ,ğ‘ƒ ) is the generator set
of ğ¶(ğµ, ğ‘ƒ ).

Then the Gray map ğ’¢ : â„¤4ğ‘› âˆ’â†’ ğ”½2ğ‘› is deï¬ned as
2
ğ’¢(ğ‘1 , . . . ğ‘ ğ‘› ) = (ğ’¢ â€² (ğ‘1 ), . . . , ğ’¢ â€² (ğ‘ ğ‘› )).
The following result is well known.
Lemma 5: The Gray map ğ’¢ is the distance-preserving map
(â„¤4ğ‘› , Lee distance) âˆ’â†’ (ğ”½2ğ‘› , Hamming distance).
2
The covering radius of a code ğ¶ over â„¤4 with respect to
the Lee distance is deï¬ned as
ğœŒ ğ¿ (ğ¶) = max {min ğ‘‘ ğ¿ (ğ‘¢, ğ‘)}.
ğ‘›
ğ‘¢âˆˆâ„¤4

ğ‘âˆˆğ¶

â„¤4ğ‘› ,

For ğ‘¢ âˆˆ
the coset of ğ¶ is deï¬ned to be the set ğ‘¢ + ğ¶ =
{ğ‘¢ + ğ‘âˆ£ğ‘ âˆˆ ğ¶}. A minimum weight vector in a coset is called
a coset leader. It is obvious that the covering radius of ğ¶
with respect to the Lee weight is the largest minimum weight
among all cosets.
Lemma 6 ([2, Proposition 3.2]): Let ğ¶ be a code over â„¤4
with ğ’¢(ğ¶) the Gray map image of ğ¶. Then

V. G OOD B INARY C ODES FROM L EXICODES OVER â„¤4

ğœŒ ğ¿ (ğ¶) = ğœŒ(ğ’¢(ğ¶))).

It was proven by Hammons et al. [9] that some of the
best known nonlinear binary codes such as the NordstromRobinson, Kerdock, Preparata, Goethals and Delsarte-Goethals
codes are Gray map images of â„¤4 -linear codes. The Gray map

Proposition 7: Let 0 = ğ¶0 âŠ‚ ğ¶1 âŠ‚ . . . âŠ‚ ğ¶ ğ‘› = ğ¶(ğµ, ğ›¿)
be the set of nested codes obtained by Algorithm ğ´ for
designed distance ğ›¿. Hence if ğ¶ ğ‘– âŠŠ ğ¶ ğ‘› is of type 4 ğ‘˜ ğ‘–1 2 ğ‘˜ ğ‘–2

3

TABLE III
L EXICODES OVER â„¤4ğ‘› WITH THE S ELECTION P ROPERTY ğ‘¤ ğ¿ (x) â‰¥ ğ›¿
ğ‘›
8

8

b1
b2
b3
b4
b5
b6
b7
b8
b1
b2
b3
b4
b5
b6
b7
b8

Basis of â„¤4ğ‘›
= 22312221
= 11311303
= 00121200
= 01313032
= 30122132
= 03213232
= 32132232
= 12201321
= 11112233
= 23100323
= 02222133
= 01133231
= 21310130
= 23101130
= 23001233
= 11203211

8

ğ›¿
5

ğº ğ¶ (ğµ, ğ‘ƒ )
a1 = 22312221
a2 = 11311303
a3 = 01030232

2

a1
a2
a3
a4
a5
a6
a7

=
=
=
=
=
=
=

a1
a2
a3
a4
a5
a1
a2
a3
a4
a1
a2
a3
a1
a2
a3
a1
a1
a2
a3
a4
a5
a6
a1
a2
a3
a4
a1
a2
a1
a2

3

8

â€

4

8

5

8

6

8
8

b1
b2
b3
b4
b5
b6
b7
b8

=
=
=
=
=
=
=
=

10003121
01001231
00103332
00012311
22233221
10302221
10312111
02311100

7
2

8

3âˆ’6

8

7

8

8

Type
43

ğ‘‘ğ¿
5

SO/S
SO

11112233
23100323
02222133
01133231
21310130
20311130
22301233

47

2

Ã—

=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=

11112233
23100323
02222133
21310130
22133112
11112233
23100323
02222133
23132112
11112233
23100323
02222133
11112233
23100323
33033123
11112233
10003121
01001231
00103332
00012311
22233221
10302221

45

3

Ã—

44

4

SO

43

5

SO

43

6

SO

41
46

10
2

SO
SO

=
=
=
=
=
=
=
=

10003121
01001231
00103332
00012311
21102321
10310132
21102321
21213100

44

6

S(ğ‘‚8 )

42

7

SO

8

Algorithm ğ´. Then the binary code ğ’¢(ğ¶ ğ¿ (ğµ, ğ›¿)) obtained
from ğ¶ ğ¿ (ğµ, ğ›¿) by the Gray image meets the Gilbert bound.
Proof: Assume that ğ’¢(ğ¶ ğ‘› ) is a binary code of minimum distance ğ‘‘, which is the same as the minimum distance of ğ¶ ğ¿ (ğµ, ğ›¿) since the Gray map is a weight preserving map. Hence we have ğ‘‘ â‰¥ ğ›¿, and by Lemma 6
ğœŒ(ğ’¢(ğ¶ ğ¿ (ğµ, ğ›¿)) = ğœŒ ğ¿ (ğ¶ ğ¿ (ğµ, ğ›¿)). Then from Proposition 7 we
have ğœŒ ğ¿ (ğ¶ ğ¿ (ğµ, ğ›¿)) â‰¤ ğ›¿ âˆ’ 1. Since ğ›¿ â‰¤ ğ‘‘, ğ’¢(ğ¶ ğ‘› ) has covering
radius less than ğ‘‘ ğ¿ âˆ’ 1. It is well known [10, p. 87], that a
code over ğ”½ ğ‘ with minimum distance ğ‘‘ and covering radius
ğ‘‘ âˆ’ 1 or less meets the Gilbert bound.

SO

R EFERENCES

2

4

[1] S. Azab, M. Zayed, M. Atrash, and M. Ashker, â€œLinear codes over â„¤4
using almost-greedy algorithm,â€ J. Islamic Univ. Gaza, vol. 11, no. 1,
pp. 43â€“58, 2003.
[2] T. Aoki, P. Gaborit, M. Harada, M. Ozeki, and P. SolÂ´ , â€œOn the covering
e
radius of â„¤4 and their lattices,â€ IEEE Trans. Inform. Theory, vol. 45,
no. 6, pp. 2162â€“2168, Sept. 1999.
[3] J. T. Bonn, â€œForcing linearity on greedy codes,â€ Designs, Codes, Crypt.,
vol. 9, no. 1, pp. 39â€“49, Aug. 1996.
[4] A. Bonnecaze, P. SolÂ´ and A. R. Calderbank, â€œQuaternary quadratic
e
residue codes and unimodular lattices,â€ IEEE Trans. Inform. Theory,
vol. 41, no. 2, pp. 366â€“377, Mar. 1995.
[5] R. A. Brualdi and V. Pless, â€œGreedy codes,â€ J. Combin. Theory A, vol.
64, pp. 10â€“30, 1993.
[6] J. H. Conway and N. J. A. Sloane, â€œLexicographic codes: Errorcorrecting codes from game theory,â€ IEEE Trans. Inform. Theory, vol.
32, no. 3, pp. 337â€“348, May 1986.
[7] J. H. Conway and N. J. A. Sloane, Sphere-packing, lattices and groups
New York:Springer-Verlag, 1988.
[8] S. T. Dougherty, A. Gulliver, and Y. H. Park, â€œOptimal linear codes over
â„¤ ğ‘š ,â€ J. Korean Math. Soc., vol. 44, no. 5, pp. 1139â€“1162, 2007.
[9] A. R. Hammons, Jr., P. V. Kumar, A. R. Calderbank, N. J. A. Sloane, and
P. SolÂ´ , â€œThe â„¤4 -linearity of Kerdock, Preparata, Goethals and related
e
codes,â€ IEEE Trans. Inform. Theory, vol. 40, no. 2, pp. 301â€“319, Mar.
1994.
[10] W. C. Huffman and V. Pless, Fundamentals of Error-correcting Codes,
New York:Cambridge Univ. Press, 2003.
[11] V. I. Levenstein, â€œA class of systematic codes,â€ Soviet Math. Dokl., vol.
1, pp. 368â€“371, 1960.
[12] A. J. van Zanten, â€œLexicographic order and linearity,â€ Designs, Codes,
Crypt., vol. 10, no. 1, pp. 85â€“97, Jan. 1997.
[13] A. J. van Zanten and I. Nengah Suparta, â€œOn the construction of linear
ğ‘-ary lexicodes,â€ Designs, Codes, Crypt., vol. 37, no. 1, pp. 15â€“29, Oct.
2005.

the covering radius ğœŒ ğ¿ (ğ¶ ğ‘– ) satisï¬es
ğ›¿ â‰¤ ğœŒ ğ¿ (ğ¶ ğ‘– ) â‰¤ 2(ğ‘› âˆ’ ğ‘˜ ğ‘–1 ) âˆ’ ğ‘˜ ğ‘–2 .

(1)

âŒŠğ›¿/2âŒ‹ â‰¤ âŒŠğ‘‘/2âŒ‹ â‰¤ ğœŒ ğ¿ (ğ¶(ğµ, ğ›¿)) â‰¤ ğ›¿ âˆ’ 1 â‰¤ ğ‘‘ âˆ’ 1.

(2)

Then we have

Proof: Assume that ğ¶ ğ‘– âŠŠ ğ¶(ğµ, ğ›¿) for some 1 < ğ‘– < ğ‘›.
Now, let ğ‘¥ âˆˆ ğ¶ ğ‘› âˆ– ğ¶ ğ‘– be a codeword of minimum weight.
Such a vector must be a coset leader of ğ¶ ğ‘– , as ğ¶ ğ‘– âŠŠ ğ¶(ğµ, ğ›¿).
Hence ğœŒ ğ¿ (ğ¶ ğ‘– ) â‰¥ ğ‘¤ğ‘¡ ğ¿ (ğ‘¥) and then ğœŒ ğ¿ (ğ¶ ğ‘– ) â‰¥ ğ›¿. The right side
of (1) is obtained from the redundancy bound [2, Theorem
4.6]. Since each vector in â„¤4ğ‘› has distance ğ›¿ âˆ’ 1 or less to
some vector in ğ¶ ğ‘› , the covering radius of ğ¶ ğ‘› is at most ğ›¿ âˆ’ 1.
By the construction we have âŒŠğ›¿/2âŒ‹ â‰¤ âŒŠğ‘‘/2âŒ‹. The left side of
(2) is obtained from the packing radius bound [2, Theorem
4.3].
Theorem 8: Let ğ¶ ğ¿ (ğµ, ğ›¿) be the lexicode obtained by

4

